[{"id":"34c2acd56bc16b503002a852a65f4137","title":"Java 集合","content":"Java 集合Collection 接口 （父接口）\n\n\n\nIterator 迭代器所有实现了Iteratable接口的类都可以通过iterator()方法获取迭代器\n注意：重新获取iterator即可重置迭代器；\n增强 for 循环\n可以对 数组 和 集合 使用；\n底层使用的仍然是 iterator；\n大写 I 可以快速生成代码（Idea）。\n\nList 接口  可重复-有顺序ArrayList\n线程不安全\n\nArrayList 维护了一个 Object 类型的数组 elementData – transient Object[] elementData &#x2F;&#x2F; transient 表示该属性不会被序列化\n\n两种构造方式（构造时数组已经初始化）：\n\n无参构造： ArrayList，则初始化 elementData 容量为0，第一次添加时，则扩容至默认容量10，如需再次扩容，则扩容为当前的1.5倍（1+1&#x2F;2）;Vector（无参情况下） 扩容倍数是2，线程安全是因为每个方法头上添加了 synchronized\n指定initialCapacity大小的构造器：初始 elementData 容量为指定大小，如需扩容，则直接扩容 elementData 为当前的1.5倍\n\n\n每次添加元素时，都会触发一次扩容检查，容量不满足 size+1 就扩容\n\n源码解读如下\n\n\n\n\nVector\n线程安全\n如果无参，默认10，满后，2倍扩容；如果指定大小，满后则每次直接2倍扩容（优先使用自定义增量capacityIncrement）\n有参构造可以指定扩容大小 Vector(int initialCapacity, int capacityIncrement)\n源码解读如下\n\n====================================================\npublic synchronized boolean add(E e) &#123;\n    modCount++;\n    ensureCapacityHelper(elementCount + 1);   // 扩容检查\n    elementData[elementCount++] = e;\n    return true;\n&#125;\n====================================================\nprivate void ensureCapacityHelper(int minCapacity) &#123;\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);    // 真正扩容方法\n&#125;\n====================================================\nprivate void grow(int minCapacity) &#123;\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //扩容的关键算法\n    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity &lt; 0)    // 扩容后仍不满足最小capacity要求\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)    // 超过最大容量\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n&#125;\n====================================================\n\n\n\nLinkedList\n\n底层维护了一个双向链表\n可以添加任意元素\n其中有两个属性first和last分别指向首节点和尾结点\n每个节点（Node对象），里面又维护了prev，next，item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表\nLinkedList 增删快，查找慢\n源码解读如下（尾插头删）\n\n-----------------------------\npublic boolean add(E e) &#123;\n        linkLast(e);\n        return true;\n    &#125;\n-----------------------------\nvoid linkLast(E e) &#123;\n        final Node&lt;E> l = last;  // 旧尾结点\n        final Node&lt;E> newNode = new Node&lt;>(l, e, null);  // 创建新节点\n        last = newNode;     // 新节点上位尾结点\n        if (l == null)\n            first = newNode; // 第一个节点 first->a  last->a\n        else\n            l.next = newNode;  // 新节点是从尾部连接的！新节点赋值->旧尾结点.next \n        size++;\n        modCount++;\n    &#125;\n-----------------------------\npublic E remove() &#123;\n        return removeFirst();  //注意是第一个\n    &#125;\npublic E removeFirst() &#123;\n        final Node&lt;E> f = first;\n        if (f == null)\n            throw new NoSuchElementException();\n        return unlinkFirst(f);\n    &#125;\n-----------------------------\nprivate E unlinkFirst(Node&lt;E> f) &#123;\n        // assert f == first &amp;&amp; f != null;\n        final E element = f.item;\n        final Node&lt;E> next = f.next;\n        f.item = null;\n        f.next = null; // help GC\n        first = next;\n        if (next == null)\n            last = null;   // 只有一个节点\n        else\n            next.prev = null;  \n        size--;\n        modCount++;\n        return element;   // 返回删除的元素\n    &#125;\n-----------------------------\n\n\n\n集合选择\nArrayList 查询快，增删慢\nLinkedList查询慢，增删快\n一般来说，程序中 80~90的业务都是查询，因此大部分情况下选择ArrayList\n也可以根据业务需要灵活选择\n\nSet 接口\nTreeSet有序，HashSet无序\n不允许重复，最多包含一个null\n\nHashSet\n\n\n\n\n\n\n\n\n如何决定元素是相同的？\n\nhashCode() 决定节点添加到数组下标的位置；\n真正地逻辑是：**(table.length -1) &amp; hash(hashCode())**\n\n\n当 hashCode() 方法算出的元素落到了某个链表上，从头到尾依次比较，有相同元素，添加失败，无相同元素，添加到链表尾部；\n可以存放null，但只能有一个（null的哈希值为0）\n\n\n\n\n\n\n\n\n\n\n\n\n源码分析\n\n底层实际上是HashMap\n底层调用的是Hashmap的API，value是占位符PRESENT – new Object()\n元素顺序取决于hash函数的结果，是一个固定的顺序\n无参构造器：default-capacity(16)  loadFactor(0.75) \n单链表长度达到9个（在添加第9个元素后立刻检查，这是由于binCount是之前的容量！）时才进入 treeifbin()方法\ntab == null || (n = tab.length) &lt; 64\n64指的是HashSet中所有的元素（包括链表上的）\n\n\nresize 扩容发生在以下三个时机：\n初始化一个HashSet，第一次添加元素时，table为null，此时扩容为长度为16的数组(无参构造，有参则初始化为指定的大小向上取2^n值)\n当前HashMap.size&gt;threshold时，成功添加第(threshold+1)个元素时，触发扩容方法\n链表的节点数大于8，若table.length&lt;64，触发扩容方法；若table.length&gt;&#x3D;64，触发树化\n\n\n不错的帖子\n从泊松分布谈起HashMap为什么默认扩容因子是0.75 - 知乎 (zhihu.com)\n2022面试题：HashMap相关问题硬核梳理_小牛呼噜噜的博客-CSDN博客\n\n\n\n// 调用链 add->put->putVal(hash->hashCode)\n---------------------------------\npublic boolean add(E e) &#123;\n    \t//PRESENT相当于一个占位符，Object[]\n        return map.put(e, PRESENT)==null;\n    &#125;\n---------------------------------\npublic V put(K key, V value) &#123;\n        return putVal(hash(key), key, value, false, true);\n    &#125;\n---------------------------------\nstatic final int hash(Object key) &#123;\n        int h;\n    \t// 由此可见，真正的哈希值是hashCode方法进一步包装的值\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    &#125;\n---------------------------------\n/**------------------------核心算法------------------------**/\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) &#123;\n        Node&lt;K,V>[] tab; Node&lt;K,V> p; int n, i;\n    \t  // 初始化 table 数组\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n    \t  // tab[i]初始化\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else &#123;\n          \t// tab[i]已经有节点了\n            Node&lt;K,V> e; K k;\n            // p 是 table[i] 的第一个元素（可能是Node或TreeNode，TreeNode是HashMap的静态内部类，已树化的节点）\n            // 以下代码判断是否是同一个对象\n            // CASE1:Node 第一个节点的hash、equals||地址 与加入节点相同\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                // CASE2:p 是一颗红黑树\n                e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else &#123;\n                // CASE3:Node 有多个节点，第一个节点不能匹配，遍历链表\n                for (int binCount = 0; ; ++binCount) &#123;\n                    // 注意此处 p.next 赋给 e\n                    if ((e = p.next) == null) &#123;\n                        p.next = newNode(hash, key, value, null);\n                        // 本次添加过后链表元素达到了9个才进行扩容，因为binCount是之前的容量\n                        if (binCount >= TREEIFY_THRESHOLD - 1) \n                            //是否要进行红黑树化判断，以下是条件，不满足执行 resize() 方法\n                            // treeifyBin方法中还有判断：tab == null || (n = tab.length) &lt; 64  \n                            // 满足才能真正树化\n                            treeifyBin(tab, hash);\n                        break;\n                    &#125;\n                    // e = p.next\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    // p 向下指一个节点\n                    p = e;\n                &#125;\n            &#125;\n            \n            // value 替换细节\n            if (e != null) &#123;\n                //此处把k-v的v替换，value是传参进来的v\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            &#125;\n        &#125;\n        ++modCount;\n        // 添加后检查，第十三个元素添加后进入if执行扩容\n        if (++size > threshold)\n            resize();\n    \t  // 为 HashMap 子类准备的方法（如LinkedList），在本类中为空实现\n        afterNodeInsertion(evict);\n        return null;\n    &#125;\n\n/**-------------------数组扩容---------------------**/\nfinal Node&lt;K,V>[] resize() &#123;\n    Node&lt;K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) &#123;\n        // 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap >= MAXIMUM_CAPACITY) &#123;\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        // 没超过最大值，就扩充为原来的2倍\n        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr &lt;&lt; 1; // double threshold\n    &#125;\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else &#123;               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    // 计算新的resize上限\n    if (newThr == 0) &#123;\n\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold = newThr;\n    @SuppressWarnings(&#123;\"rawtypes\"，\"unchecked\"&#125;)\n        Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap];\n    table = newTab;\n    if (oldTab != null) &#123;\n        // 把每个bucket都移动到新的buckets中\n        for (int j = 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V> e;\n            if ((e = oldTab[j]) != null) &#123;\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash &amp; (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap);\n                else &#123; // 链表优化重hash的代码块\n                    Node&lt;K,V> loHead = null, loTail = null; // 原索引存放的引用\n                    Node&lt;K,V> hiHead = null, hiTail = null; // 原索引+oldCap存放的引用\n                    Node&lt;K,V> next;\n                    do &#123;\n                        next = e.next;\n                       /*\n                       \t取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作\n                     \t （也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。\n                      */\n                        // 原索引\n                        if ((e.hash &amp; oldCap) == 0) &#123;\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e; // 尾插\n                            loTail = e; // 尾插\n                        &#125; else &#123; // 原索引+oldCap\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        &#125;\n                    &#125; while ((e = next) != null);\n                    // 原索引放到bucket里\n                    if (loTail != null) &#123;\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    &#125;\n                    // 原索引+oldCap放到bucket里\n                    if (hiTail != null) &#123;\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;\n\n\n\n\n\nLinkedHashSet\n\n\n\n\n\n\n\n\n继承HashSet，实现Set\n\nHashMap维护对象是 Node ，LinkedHashSet维护对象是 Entry extends HashMap.Node\n底层维护了一个哈希表和双向链表\n每一个节点有pre和next属性，这样可以形成双向链表\n在添加一个元素时，先求hash值，再求索引，确定该元素在hashtable中的位置，然后将添加的元素加入到双向链表中（如果已经存在，则不添加，原则上通hashset一致）\n这样LinkedHashSet能确保插入顺序和遍历顺序一致\n源码解读\n\n/*LinkedHashSet内部类 Entry ，将来会取代Node成为LinkedHashSet的table的节点元素*/\nstatic class Entry&lt;K,V> extends HashMap.Node&lt;K,V> &#123;\n        Entry&lt;K,V> before, after;\n        Entry(int hash, K key, V value, Node&lt;K,V> next) &#123;\n            super(hash, key, value, next);\n        &#125;\n    &#125;\n\n\n\n\n\n\n\nTreeSet\n使用无参构造器时，元素仍是无序的\nTreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树\n源码解析如下\n\npublic V put(K key, V value) &#123;\n        Entry&lt;K,V> t = root;\n    \t// 第一次添加元素，注意节点对象是 Entry\n        if (t == null) &#123;\n            compare(key, key); // 此处的compare是为了检查 key 是否为空值\n            \n            root = new Entry&lt;>(key, value, null);\n            size = 1;\n            modCount++;\n            return null;\n        &#125;\n        int cmp;\n        Entry&lt;K,V> parent;\n        // split comparator and comparable paths\n        Comparator&lt;? super K> cpr = comparator;\n        if (cpr != null) &#123;\n            do &#123;\n                // 遍历所有的 key，给key找适当的位置\n                parent = t;\n                cmp = cpr.compare(key, t.key);  //绑定到定义的 compare 方法\n                if (cmp &lt; 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else // 发现相等的 key ，用 value 的值覆盖这个 key 的 value，且方法退出\n                    return t.setValue(value);\n            &#125; while (t != null);\n        &#125;\n        else &#123;\n            if (key == null)\n                throw new NullPointerException();\n            @SuppressWarnings(\"unchecked\")\n                Comparable&lt;? super K> k = (Comparable&lt;? super K>) key;\n            do &#123;\n                parent = t;\n                cmp = k.compareTo(t.key);\n                if (cmp &lt; 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            &#125; while (t != null);\n        &#125;\n        Entry&lt;K,V> e = new Entry&lt;>(key, value, parent);\n        if (cmp &lt; 0)\n            parent.left = e;\n        else\n            parent.right = e;\n        fixAfterInsertion(e);\n        size++;\n        modCount++;\n        return null;\n    &#125;\n\n\n\n\n\nMap 接口\nTreeMap有序，HashMap无序\nkey 不允许重复(null也不能重复），value可以重复\nk-v 最后是 HashMap$Node node &#x3D; newNode(hash , key , value , null)\nk-v 是为了方便程序员进行遍历设计的，会创建 EntrySet 集合，该集合存放的元素类型 Entry ，而一个 Entry 对象就有 k-v EntrySet&lt;Entry&lt;K,V&gt;&gt; 即： transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;\nentrySet 中，定义的类型是 Map.Entry , 但实际上存放的是 HashMap$Node , 这是因为 HashMap$Node implements Map.Entry static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;\n当把 HashMap$Node 对象存放到 entrySet 就方便我们的遍历，因为 Map.Entry 提供了重要方法 K getKey() – V getValue()\n\nMap 遍历\n增强 FOR\n迭代器 Iterator\nvalues() 方法 ，此方法返回集合 Collection ，可以使用以上两种遍历方式\nentrySet() 方法 ， 此方法返回 Set –&gt; EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;  ， 可以使用 1 ，2 两种方式遍历\n\nHashMap\n\n\n\n\n当添加 key-val 时，通过 key 的哈希值得到在table的索引，然后判断该索引处是否有元素，如果没有元素则直接添加，如果有元素则继续判断该元素的 key 和准备加入的 key 是否相等，如果相等，则直接替换 val；如果不相等则需要判断是树结构还是链表结构，做出相应处理，如果添加时发现容量不够，则需要扩容。\n执行构造 new HashMap() ，初始化加载因子 loadfactor &#x3D; 0.75 &amp; hashMap$Node[] table &#x3D; null\n执行 put 调用 putVal() ，详细细节见 HashSet\n\n\n\n\n\nHashtable\n实现了 Map 集合，即存放 k-v 键值对，key不能重复\nHashtable 的键和值都不能为 null ，否则抛出 NullPointerException\nHashtable 使用方法基本上和 HashMap 一致\nHashtable 线程安全\n默认值 initialCapacity-11 loadFactor-0.75，扩容方式 2*old+1\n源码解析如下\n\n--------------------------------------------\n// 无参构造 默认大小是 11 ，loadFactor仍然是 0.75，所以threshold是 11*0.75=8\npublic Hashtable() &#123;\n        this(11, 0.75f);\n    &#125;\n--------------------------------------------\npublic synchronized V put(K key, V value) &#123;\n        // Make sure the value is not null\n        if (value == null) &#123;\n            throw new NullPointerException();\n        &#125;\n\n        // Makes sure the key is not already in the hashtable.\n        Entry&lt;?,?> tab[] = table;\n        int hash = key.hashCode();\n        int index = (hash &amp; 0x7FFFFFFF) % tab.length;\n        @SuppressWarnings(\"unchecked\")\n        Entry&lt;K,V> entry = (Entry&lt;K,V>)tab[index];\n        for(; entry != null ; entry = entry.next) &#123;\n            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;\n                V old = entry.value;\n                entry.value = value;\n                return old;\n            &#125;\n        &#125;\n\n        addEntry(hash, key, value, index);\n        return null;\n    &#125;\n-------------------------------------------------------------\nprivate void addEntry(int hash, K key, V value, int index) &#123;\n        modCount++;\n\n        Entry&lt;?,?> tab[] = table;\n        if (count >= threshold) &#123;\n            // Rehash the table if the threshold is exceeded\n            rehash();\n\n            tab = table;\n            hash = key.hashCode();\n            index = (hash &amp; 0x7FFFFFFF) % tab.length;\n        &#125;\n\n        // Creates the new entry.\n        @SuppressWarnings(\"unchecked\")\n        Entry&lt;K,V> e = (Entry&lt;K,V>) tab[index];\n        tab[index] = new Entry&lt;>(hash, key, value, e);\n        count++;\n    &#125;\n-------------------------------------------------------------\nprotected void rehash() &#123;\n        int oldCapacity = table.length;\n        Entry&lt;?,?>[] oldMap = table;\n\n        //扩容机制如下 2*oldCapacity+1\n        int newCapacity = (oldCapacity &lt;&lt; 1) + 1;\n        if (newCapacity - MAX_ARRAY_SIZE > 0) &#123;\n            if (oldCapacity == MAX_ARRAY_SIZE)\n                // Keep running with MAX_ARRAY_SIZE buckets\n                return;\n            newCapacity = MAX_ARRAY_SIZE;\n        &#125;\n    \t//数组扩容\n        Entry&lt;?,?>[] newMap = new Entry&lt;?,?>[newCapacity];\n\n        modCount++;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n        table = newMap;\n\n        for (int i = oldCapacity ; i-- > 0 ;) &#123;\n            for (Entry&lt;K,V> old = (Entry&lt;K,V>)oldMap[i] ; old != null ; ) &#123;\n                Entry&lt;K,V> e = old;\n                old = old.next;\n\n                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;\n                e.next = (Entry&lt;K,V>)newMap[index];\n                newMap[index] = e;\n            &#125;\n        &#125;\n    &#125;\n\n\n\nProperties\n继承自 Hashtable，仍然以 k-v 键值对保存数据\n使用方式与 Hashtable 类似\nProperties可以从 xxx.properties文件中，加载数据到其创建的对象中，并对其修改\n\nTreeMap这个类不依赖hashCode和equals\n\n使用比较器构造器\n\n&#96;&#96;&#96;javapublic TreeSet(Comparator&lt;? super E&gt; comparator) {    this(new TreeMap&lt;&gt;(comparator));}\n2. 第一次添加，把k-v封装到 Entry 对象，放入 root\n\n   - &#96;&#96;&#96;java\n     Entry&lt;K,V&gt; t &#x3D; root;\n     if (t &#x3D;&#x3D; null) &#123;\n         compare(key, key); &#x2F;&#x2F; type (and possibly null) check\n     \n         root &#x3D; new Entry&lt;&gt;(key, value, null);\n         size &#x3D; 1;\n         modCount++;\n         return null;\n     &#125;\n\n\n以后添加\n\n&#96;&#96;&#96;javaint cmp;Entry&lt;K,V&gt; parent;&#x2F;&#x2F; split comparator and comparable pathsComparator&lt;? super K&gt; cpr &#x3D; comparator;if (cpr !&#x3D; null) {do {  &#x2F;&#x2F; 遍历所有key，给key找适当的位置    parent &#x3D; t;    cmp &#x3D; cpr.compare(key, t.key); &#x2F;&#x2F;调用的是传入的比较器    if (cmp &lt; 0)        t &#x3D; t.left;    else if (cmp &gt; 0)        t &#x3D; t.right;    else          &#x2F;&#x2F; 发现已经有重复的key，覆盖value并返回        return t.setValue(value);} while (t !&#x3D; null);}\n\n\n## 集合选择\n\n1. 先判断存储的类型（一组对象或一组键值对）\n2. 一组对象：Collection接口实现类\n   1. 允许重复：List\n      - 增删多：LinkedList（底层维护了一个双向链表）\n      - 改查多：ArrayList（底层维护Object类型可变数组）\n   2. 不允许重复：Set\n      - 无序：HashSet（底层是HashMap，维护了一个哈希表，即数组+链表+红黑树）\n      - 排序：TreeSet\n      - 插入和取出顺序一致：LinkedHashSet（底层维护了数组+双向链表）\n3. 一组键值对：Map\n   - 键无序：HashMap（底层是哈希表）\n   - 键排序：TreeMap\n   - 键插入和取出顺序一致：LinkedHashMap\n   - 文件操作：Properties\n\n\n\n## Collections 工具类\n\n1. 排序相关\n   - reverse()   &#x2F;&#x2F; 反转\n   - shuffle()     &#x2F;&#x2F; 乱序\n   - sort()        &#x2F;&#x2F; 排序 ，可以定义比较器\n   - swap()     &#x2F;&#x2F; 交换\n2. 查找、替换\n   - max()   &#x2F;&#x2F; 可以定义比较器\n   - **frequency()**   &#x2F;&#x2F; 某元素出现频率\n   - copy()     &#x2F;&#x2F; 注意数组越界问题！\n   - replaceAll()  &#x2F;&#x2F; 集合中某元素替换\n\n\n\n&#96;&#96;&#96;java\n\n\n\n\n","slug":"Java集合详解","date":"2022-09-22T01:13:17.000Z","categories_index":"","tags_index":"Java,Python","author_index":"JuneQQQ"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"nihao\n","slug":"test","date":"2022-09-22T01:13:17.000Z","categories_index":"","tags_index":"","author_index":"JuneQQQ"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-09-20T06:36:56.163Z","categories_index":"","tags_index":"","author_index":"JuneQQQ"}]