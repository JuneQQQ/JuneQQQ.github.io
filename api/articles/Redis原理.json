{"title":"Redis原理","uid":"0f9864dd4863efa9b41c7bba5ace71e0","slug":"Redis原理","date":"2022-09-30T09:24:54.000Z","updated":"2022-09-30T09:29:04.451Z","comments":true,"path":"api/articles/Redis原理.json","keywords":null,"cover":[],"content":"<h1 id=\"Redis原理篇\"><a href=\"#Redis原理篇\" class=\"headerlink\" title=\"Redis原理篇\"></a>Redis原理篇</h1><h2 id=\"1、原理篇-Redis数据结构\"><a href=\"#1、原理篇-Redis数据结构\" class=\"headerlink\" title=\"1、原理篇-Redis数据结构\"></a>1、原理篇-Redis数据结构</h2><h3 id=\"1-1-动态字符串\"><a href=\"#1-1-动态字符串\" class=\"headerlink\" title=\"1.1 动态字符串\"></a>1.1 动态字符串</h3><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p>\n<p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：<br>获取字符串长度的需要通过运算<br>非二进制安全<br>不可修改<br>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。<br>例如，我们执行命令：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984583289.png\" alt=\"1653984583289\"></p>\n<p>那么Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“虎哥”的SDS。</p>\n<p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984624671.png\" alt=\"1653984624671\"></p>\n<p>例如，一个包含字符串“name”的sds结构如下：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984648404.png\" alt=\"1653984648404\"></p>\n<p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984787383.png\" alt=\"1653984787383\"></p>\n<p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p>\n<p><strong>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</strong></p>\n<p><strong>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</strong></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984822363.png\" alt=\"1653984822363\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984838306.png\" alt=\"1653984838306\"></p>\n<h3 id=\"1-2-intset\"><a href=\"#1-2-intset\" class=\"headerlink\" title=\"1.2 intset\"></a>1.2 intset</h3><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984923322.png\" alt=\"1653984923322\"></p>\n<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984942385.png\" alt=\"1653984942385\"></p>\n<p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985149557.png\" alt=\"1653985149557\"></p>\n<p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  &#x3D; 6字节</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985197214.png\" alt=\"1653985197214\"></p>\n<p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p>\n<ul>\n<li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li>\n<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>\n<li>将待添加的元素放入数组末尾</li>\n<li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985276621.png\" alt=\"1653985276621\"></p>\n<p>源码如下：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985304075.png\" alt=\"1653985304075\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985327653.png\" alt=\"1653985327653\"></p>\n<p>小总结：</p>\n<p>Intset可以看做是特殊的整数数组，具备一些特点：</p>\n<ul>\n<li>Redis会确保Intset中的元素唯一、有序</li>\n<li>具备类型升级机制，可以节省内存空间</li>\n<li>底层采用二分查找方式来查询</li>\n</ul>\n<h3 id=\"1-3-Dict\"><a href=\"#1-3-Dict\" class=\"headerlink\" title=\"1.3 Dict\"></a>1.3 Dict</h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：<strong>哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</strong></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985396560.png\" alt=\"1653985396560\"></p>\n<p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1&#x3D;v1，假设k1的哈希值h &#x3D;1，则1&amp;3 &#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985497735.png\" alt=\"1653985497735\"></p>\n<p><strong>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</strong></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985570612.png\" alt=\"1653985570612\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985586543.png\" alt=\"1653985586543\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985640422.png\" alt=\"1653985640422\"></p>\n<p><strong>Dict的扩容</strong></p>\n<p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在<strong>每次新增键值对时</strong>都会检查负载因子<strong>（LoadFactor &#x3D; used&#x2F;size）</strong> ，满足以下两种情况时会触发哈希表扩容：<br><strong>哈希表的 LoadFactor &gt;&#x3D; 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；</strong><br><strong>哈希表的 LoadFactor &gt; 5 ；</strong></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985716275.png\" alt=\"1653985716275\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985743412.png\" alt=\"1653985743412\"></p>\n<p><strong>Dict的rehash</strong></p>\n<p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p>\n<ul>\n<li><p>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</p>\n<ul>\n<li><strong>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</strong></li>\n<li><strong>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</strong></li>\n</ul>\n</li>\n<li><p>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</p>\n</li>\n<li><p>设置dict.rehashidx &#x3D; 0，标示开始rehash</p>\n</li>\n<li><p>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</p>\n</li>\n<li><p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p>\n</li>\n<li><p>将rehashidx赋值为-1，代表rehash结束</p>\n</li>\n<li><p><strong>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</strong></p>\n</li>\n</ul>\n<p>整个过程可以描述成：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985824540.png\" alt=\"1653985824540\"></p>\n<p>小总结：</p>\n<p>Dict的结构：</p>\n<ul>\n<li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li>\n<li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li>\n</ul>\n<p>Dict的伸缩：</p>\n<ul>\n<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>\n<li>当LoadFactor小于0.1时，Dict收缩</li>\n<li>扩容大小为第一个大于等于used + 1的2^n</li>\n<li>收缩大小为第一个大于等于used 的2^n</li>\n<li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li>\n<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>\n</ul>\n<h3 id=\"1-4-ZipList\"><a href=\"#1-4-ZipList\" class=\"headerlink\" title=\"1.4 ZipList\"></a>1.4 ZipList</h3><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为 O(1)。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653985987327.png\" alt=\"1653985987327\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986020491.png\" alt=\"1653986020491\"></p>\n<table>\n<thead>\n<tr>\n<th><strong>属性</strong></th>\n<th><strong>类型</strong></th>\n<th><strong>长度</strong></th>\n<th><strong>用途</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zlbytes</td>\n<td>uint32_t</td>\n<td>4 字节</td>\n<td>记录整个压缩列表占用的内存字节数</td>\n</tr>\n<tr>\n<td>zltail</td>\n<td>uint32_t</td>\n<td>4 字节</td>\n<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td>\n</tr>\n<tr>\n<td>zllen</td>\n<td>uint16_t</td>\n<td>2 字节</td>\n<td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>\n</tr>\n<tr>\n<td>entry</td>\n<td>列表节点</td>\n<td>不定</td>\n<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>\n</tr>\n<tr>\n<td>zlend</td>\n<td>uint8_t</td>\n<td>1 字节</td>\n<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>\n</tr>\n</tbody></table>\n<p><strong>ZipListEntry</strong></p>\n<p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986055253.png\" alt=\"1653986055253\"></p>\n<ul>\n<li><p><code>previous_entry_length</code>：前一节点的长度，占1个或5个字节。</p>\n<ul>\n<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>\n<li>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li>\n</ul>\n</li>\n<li><p><code>encoding</code>：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p>\n</li>\n<li><p><code>contents</code>：负责保存节点的数据，可以是字符串或整数</p>\n</li>\n</ul>\n<p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p>\n<p><strong>Encoding编码</strong></p>\n<p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以<strong>“00”、“01”或者“10”</strong>开头，则证明content是字符串</p>\n<table>\n<thead>\n<tr>\n<th><strong>编码</strong></th>\n<th><strong>编码长度</strong></th>\n<th><strong>字符串大小</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>|<code>00</code>pppppp|</td>\n<td>1 bytes</td>\n<td>&lt;&#x3D; 63 bytes</td>\n</tr>\n<tr>\n<td>|<code>01</code>pppppp|qqqqqqqq|</td>\n<td>2 bytes</td>\n<td>&lt;&#x3D; 16383 bytes</td>\n</tr>\n<tr>\n<td>|<code>10</code>000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>\n<td>5 bytes</td>\n<td>&lt;&#x3D; 4294967295 bytes</td>\n</tr>\n</tbody></table>\n<p>例如，我们要保存字符串：“ab”和 “bc”</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986172002.png\" alt=\"1653986172002\"></p>\n<p> ZipListEntry中的encoding编码分为字符串和整数两种：</p>\n<ul>\n<li>整数：如果encoding是以“<strong>11</strong>”开始，则证明content是整数，且encoding固定只占用1个字节</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>编码</strong></th>\n<th><strong>编码长度</strong></th>\n<th><strong>整数类型</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>11</code>000000</td>\n<td>1</td>\n<td>int16_t（2 bytes）</td>\n</tr>\n<tr>\n<td><code>11</code>010000</td>\n<td>1</td>\n<td>int32_t（4 bytes）</td>\n</tr>\n<tr>\n<td><code>11</code>100000</td>\n<td>1</td>\n<td>int64_t（8 bytes）</td>\n</tr>\n<tr>\n<td><code>11</code>110000</td>\n<td>1</td>\n<td>24位有符整数(3 bytes)</td>\n</tr>\n<tr>\n<td><code>11</code>111110</td>\n<td>1</td>\n<td>8位有符整数(1 bytes)</td>\n</tr>\n<tr>\n<td><code>11</code>11xxxx</td>\n<td>1</td>\n<td><strong>直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</strong></td>\n</tr>\n</tbody></table>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986282879.png\" alt=\"1653986282879\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986217182.png\" alt=\"1653986217182\"></p>\n<h3 id=\"1-5-ZipList的连锁更新问题\"><a href=\"#1-5-ZipList的连锁更新问题\" class=\"headerlink\" title=\"1.5 ZipList的连锁更新问题\"></a>1.5 ZipList的连锁更新问题</h3><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986328124.png\" alt=\"1653986328124\"></p>\n<p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p>\n<p><strong>小总结：</strong></p>\n<p><strong>ZipList特性：</strong></p>\n<ul>\n<li>压缩列表的可以看做一种连续内存空间的”双向链表”</li>\n<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li>\n<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>\n<li><strong>增或删较大数据时有可能发生连续更新问题</strong></li>\n</ul>\n<h3 id=\"1-6-QuickList\"><a href=\"#1-6-QuickList\" class=\"headerlink\" title=\"1.6 QuickList\"></a>1.6 QuickList</h3><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p>\n<pre><code>答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。\n</code></pre>\n<p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p>\n<pre><code>答：我们可以创建多个ZipList来分片存储数据。\n</code></pre>\n<p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p>\n<pre><code>答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。\n</code></pre>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986474927.png\" alt=\"1653986474927\"></p>\n<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code>来限制。该参数对应下面的<code>fill</code>变量<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p>\n<ul>\n<li>-1：每个ZipList的内存占用不能超过4kb</li>\n<li>-2：每个ZipList的内存占用不能超过8kb</li>\n<li>-3：每个ZipList的内存占用不能超过16kb</li>\n<li>-4：每个ZipList的内存占用不能超过32kb</li>\n<li>-5：每个ZipList的内存占用不能超过64kb</li>\n</ul>\n<p><strong>其默认值为 -2：</strong></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986642777.png\" alt=\"1653986642777\"></p>\n<p>以下是QuickList的和QuickListNode的结构源码：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986667228.png\" alt=\"1653986667228\"></p>\n<p>我们接下来用一段流程图来描述当前的这个结构</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986718554.png\" alt=\"1653986718554\"></p>\n<p>总结：</p>\n<p>QuickList的特点：</p>\n<ul>\n<li>是一个节点为ZipList的双端链表</li>\n<li>节点采用ZipList，解决了传统链表的内存占用问题</li>\n<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>\n<li>中间节点可以压缩，进一步节省了内存，控制参数：<code>list-compress-depth</code><ul>\n<li>0 特殊值，不压缩</li>\n<li>1 首位各不压缩1个节点，中间节点全部压缩</li>\n<li>2 首位各不压缩2个节点，中间节点全部压缩</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-7-SkipList\"><a href=\"#1-7-SkipList\" class=\"headerlink\" title=\"1.7 SkipList\"></a>1.7 SkipList</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986771309.png\" alt=\"1653986771309\"></p>\n<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986813240.png\" alt=\"1653986813240\"></p>\n<p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986877620.png\" alt=\"1653986877620\"></p>\n<p>小总结：</p>\n<p>SkipList的特点：</p>\n<ul>\n<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>\n<li>节点按照score值排序，score值一样则按照ele字典排序</li>\n<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>\n<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>\n<li>增删改查效率与红黑树基本一致，实现却更简单</li>\n</ul>\n<h3 id=\"1-8-RedisObject\"><a href=\"#1-8-RedisObject\" class=\"headerlink\" title=\"1.8 RedisObject\"></a>1.8 RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，<strong>共16个字节</strong>，源码如下：</p>\n<p>1、什么是redisObject：<br>从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string, list, hash、set、sorted set等。我们可以看到，key的类型固定是string，而value可能的类型是多个。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是用⼀个dict来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653986956618.png\" alt=\"1653986956618\"></p>\n<p>Redis的编码方式</p>\n<p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>\n<table>\n<thead>\n<tr>\n<th><strong>编号</strong></th>\n<th><strong>编码方式</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>OBJ_ENCODING_RAW</td>\n<td>raw编码动态字符串</td>\n</tr>\n<tr>\n<td>1</td>\n<td>OBJ_ENCODING_INT</td>\n<td>long类型的整数的字符串</td>\n</tr>\n<tr>\n<td>2</td>\n<td>OBJ_ENCODING_HT</td>\n<td>hash表（字典dict）</td>\n</tr>\n<tr>\n<td>3</td>\n<td>OBJ_ENCODING_ZIPMAP</td>\n<td>已废弃</td>\n</tr>\n<tr>\n<td>4</td>\n<td>OBJ_ENCODING_LINKEDLIST</td>\n<td>双端链表</td>\n</tr>\n<tr>\n<td>5</td>\n<td>OBJ_ENCODING_ZIPLIST</td>\n<td>压缩列表</td>\n</tr>\n<tr>\n<td>6</td>\n<td>OBJ_ENCODING_INTSET</td>\n<td>整数集合</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OBJ_ENCODING_SKIPLIST</td>\n<td>跳表</td>\n</tr>\n<tr>\n<td>8</td>\n<td>OBJ_ENCODING_EMBSTR</td>\n<td>embstr的动态字符串</td>\n</tr>\n<tr>\n<td>9</td>\n<td>OBJ_ENCODING_QUICKLIST</td>\n<td>快速列表</td>\n</tr>\n<tr>\n<td>10</td>\n<td>OBJ_ENCODING_STREAM</td>\n<td>Stream流</td>\n</tr>\n</tbody></table>\n<p>五种数据结构</p>\n<p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>数据类型</strong></th>\n<th><strong>编码方式</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OBJ_STRING</td>\n<td>int、embstr、raw</td>\n</tr>\n<tr>\n<td>OBJ_LIST</td>\n<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>\n</tr>\n<tr>\n<td>OBJ_SET</td>\n<td>intset、HT</td>\n</tr>\n<tr>\n<td>OBJ_ZSET</td>\n<td>ZipList、HT、SkipList</td>\n</tr>\n<tr>\n<td>OBJ_HASH</td>\n<td>ZipList、HT</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-9-基本类型-String\"><a href=\"#1-9-基本类型-String\" class=\"headerlink\" title=\"1.9 基本类型-String\"></a>1.9 基本类型-String</h3><p>String是Redis中最常见的数据存储类型：</p>\n<p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，<strong>存储上限为512mb</strong>。</p>\n<p>如果存储的SDS长度小于<code>44</code>字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时</p>\n<p>只需要调用一次内存分配函数，效率更高。</p>\n<p>（1）底层实现⽅式：<strong>动态字符串sds 或者 long</strong><br>String的内部存储结构⼀般是sds（Simple Dynamic String，可以动态扩展内存），但是如果⼀个String类型的value的值是数字，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987103450.png\" alt=\"1653987103450\"></p>\n<p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987159575.png\" alt=\"1653987159575\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987172764.png\" alt=\"1653987172764\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987202522.png\" alt=\"1653987202522\"></p>\n<p>确切地说，String在Redis中是⽤⼀个robj来表示的。</p>\n<p>用来表示String的robj可能编码成3种内部表⽰：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。<br>其中前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。<br>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。对⼀个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。11</p>\n<h3 id=\"2-0-基本类型-List\"><a href=\"#2-0-基本类型-List\" class=\"headerlink\" title=\"2.0 基本类型-List\"></a>2.0 基本类型-List</h3><p>Redis的List类型可以从首、尾操作列表中的元素：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987240622.png\" alt=\"1653987240622\"></p>\n<p>哪一个数据结构能满足上述特征？</p>\n<ul>\n<li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li>\n<li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li>\n<li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li>\n</ul>\n<p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p>\n<p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p>\n<p>在3.2版本之后，Redis统一采用QuickList来实现List：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987313461.png\" alt=\"1653987313461\"></p>\n<h3 id=\"2-1-基本类型-Set\"><a href=\"#2-1-基本类型-Set\" class=\"headerlink\" title=\"2.1 基本类型-Set\"></a>2.1 基本类型-Set</h3><p>Set是Redis中的单列集合，满足下列特点：</p>\n<ul>\n<li>不保证有序性</li>\n<li>保证元素唯一</li>\n<li>求交集、并集、差集</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987342550.png\" alt=\"1653987342550\"></p>\n<p>可以看出，Set对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？<br>HashTable，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）</p>\n<p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。<br>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。<br>当存储的所有数据都是整数，并且元素数量不超过<strong>set-max-intset-entries</strong>时（默认512），Set会采用IntSet编码，以节省内存</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987388177.png\" alt=\"1653987388177\"></p>\n<p>结构如下：</p>\n<pre><code>![1653987454403](https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653987454403.png)\n</code></pre>\n<h3 id=\"2-2、基本类型-ZSET\"><a href=\"#2-2、基本类型-ZSET\" class=\"headerlink\" title=\"2.2、基本类型-ZSET\"></a>2.2、基本类型-ZSET</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p>\n<ul>\n<li>可以根据score值排序后</li>\n<li>member必须唯一</li>\n<li>可以根据member查询分数</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992091967.png\" alt=\"1653992091967\"></p>\n<p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p>\n<ul>\n<li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li>\n<li>HT（Dict）：可以键值存储，并且可以根据key找value</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992121692.png\" alt=\"1653992121692\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992172526.png\" alt=\"1653992172526\"></p>\n<p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p>\n<ul>\n<li>元素数量小于<code>zset_max_ziplist_entries</code>，默认值128</li>\n<li>每个元素都小于<code>zset_max_ziplist_value</code>字节，默认值64</li>\n</ul>\n<p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>\n<ul>\n<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>\n<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992238097.png\" alt=\"1653992238097\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992299740.png\" alt=\"1653992299740\"></p>\n<h3 id=\"2-3、基本类型-Hash\"><a href=\"#2-3、基本类型-Hash\" class=\"headerlink\" title=\"2.3、基本类型-Hash\"></a>2.3、基本类型-Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p>\n<ul>\n<li>都是键值存储</li>\n<li>都需求根据键获取值</li>\n<li>键必须唯一</li>\n</ul>\n<p>区别如下：</p>\n<ul>\n<li>zset的键是member，值是score；hash的键和值都是任意值</li>\n<li>zset要根据score排序；hash则无需排序</li>\n</ul>\n<p>（1）底层实现方式：压缩列表ziplist 或者 字典dict<br>当Hash中数据项比较少的情况下，Hash底层才⽤压缩列表ziplist进⾏存储数据，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p>\n<p><code>hash-max-ziplist-entries 512</code></p>\n<p><code>hash-max-ziplist-value 64</code></p>\n<p>当满足上面两个条件其中之⼀的时候，Redis就使⽤dict字典来实现hash。<br>Redis的hash之所以这样设计，是因为当ziplist变得很⼤的时候，它有如下几个缺点：</p>\n<ul>\n<li>每次插⼊或修改引发的realloc操作会有更⼤的概率造成内存拷贝，从而降低性能。</li>\n<li>⼀旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更⼤的⼀块数据。</li>\n<li>当ziplist数据项过多的时候，在它上⾯查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>\n</ul>\n<p>总之，ziplist本来就设计为各个数据项挨在⼀起组成连续的内存空间，这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存realloc，可能导致内存拷贝。</p>\n<p>hash结构如下：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992339937.png\" alt=\"1653992339937\"></p>\n<p>zset集合如下：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992360355.png\" alt=\"1653992360355\"></p>\n<p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可：</p>\n<p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value</p>\n<p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个：</p>\n<ul>\n<li><strong>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</strong></li>\n<li><strong>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</strong></li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653992413406.png\" alt=\"1653992413406\"></p>\n<h2 id=\"2、原理篇-Redis网络模型\"><a href=\"#2、原理篇-Redis网络模型\" class=\"headerlink\" title=\"2、原理篇-Redis网络模型\"></a>2、原理篇-Redis网络模型</h2><h3 id=\"2-1-用户空间和内核态空间\"><a href=\"#2-1-用户空间和内核态空间\" class=\"headerlink\" title=\"2.1 用户空间和内核态空间\"></a>2.1 用户空间和内核态空间</h3><p>服务器大多都采用Linux系统，这里我们以Linux为例来讲解:</p>\n<p>ubuntu和Centos 都是Linux的发行版，发行版可以看成对linux包了一层壳，任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653844970346.png\" alt=\"1653844970346\"></p>\n<p>用户的应用，比如redis，mysql等其实是没有办法去执行访问我们操作系统的硬件的，所以我们可以通过发行版的这个壳子去访问内核，再通过内核去访问计算机硬件</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653845147190.png\" alt=\"1653845147190\" style=\"zoom: 80%;\" />\n\n<p>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653896065386.png\" alt=\"1653896065386\" style=\"zoom: 80%;\" />\n\n\n\n<p>我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简介的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和<strong>内核隔离开</strong></p>\n<p>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></p>\n<p>什么是寻址空间呢？我们的应用程序也好，还是内核空间也好，都是没有办法直接去物理内存的，而是通过分配一些虚拟内存映射到物理内存中，我们的内核和应用程序去访问虚拟内存的时候，就需要一个虚拟地址，这个地址是一个无符号的整数，比如一个32位的操作系统，他的带宽就是32，他的虚拟地址就是2的32次方，也就是说他寻址的范围就是0~2的32次方， 这片寻址空间对应的就是2的32个字节，就是4GB，这个4GB，会有3个GB分给用户空间，会有1GB给内核系统</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653896377259.png\" alt=\"1653896377259\"></p>\n<p>在linux中，他们权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p>\n<p>比如：</p>\n<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>\n<p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p>\n<p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p>\n<p>针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望read也好，还是wait for data也最好都不要等待，或者时间尽量的短。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653896687354.png\" alt=\"1653896687354\"></p>\n<h3 id=\"2-2-网络模型-阻塞IO\"><a href=\"#2-2-网络模型-阻塞IO\" class=\"headerlink\" title=\"2.2.网络模型-阻塞IO\"></a>2.2.网络模型-阻塞IO</h3><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p>\n<ul>\n<li>阻塞IO（Blocking IO）</li>\n<li>非阻塞IO（Nonblocking IO）</li>\n<li>IO多路复用（IO Multiplexing）</li>\n<li>信号驱动IO（Signal Driven IO）</li>\n<li>异步IO（Asynchronous IO）</li>\n</ul>\n<p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653897115346.png\" alt=\"1653897115346\"></p>\n<p>具体流程如下图：</p>\n<p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO</p>\n<p>总结如下：</p>\n<p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p>\n<p><strong>阶段一：</strong></p>\n<ul>\n<li>用户进程尝试读取数据（比如网卡数据）</li>\n<li>此时数据尚未到达，内核需要等待数据</li>\n<li>此时用户进程也处于阻塞状态</li>\n</ul>\n<p>阶段二：</p>\n<ul>\n<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>\n<li>将内核数据拷贝到用户缓冲区</li>\n<li>拷贝过程中，用户进程依然阻塞等待</li>\n<li>拷贝完成，用户进程解除阻塞，处理数据</li>\n</ul>\n<p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653897270074.png\" alt=\"1653897270074\"></p>\n<h3 id=\"2-3-网络模型-非阻塞IO\"><a href=\"#2-3-网络模型-非阻塞IO\" class=\"headerlink\" title=\"2.3 网络模型-非阻塞IO\"></a>2.3 网络模型-非阻塞IO</h3><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p>\n<p>阶段一：</p>\n<ul>\n<li>用户进程尝试读取数据（比如网卡数据）</li>\n<li>此时数据尚未到达，内核需要等待数据</li>\n<li>返回异常给用户进程</li>\n<li>用户进程拿到error后，再次尝试读取</li>\n<li>循环往复，直到数据就绪</li>\n</ul>\n<p>阶段二：</p>\n<ul>\n<li>将内核数据拷贝到用户缓冲区</li>\n<li>拷贝过程中，用户进程依然阻塞等待</li>\n<li>拷贝完成，用户进程解除阻塞，处理数据</li>\n<li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653897490116.png\" alt=\"1653897490116\"></p>\n<h3 id=\"2-4-网络模型-IO多路复用\"><a href=\"#2-4-网络模型-IO多路复用\" class=\"headerlink\" title=\"2.4 网络模型-IO多路复用\"></a>2.4 网络模型-IO多路复用</h3><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p>\n<p>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。<br>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</p>\n<p>所以怎么看起来以上两种方式性能都不好</p>\n<p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p>\n<p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p>\n<p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>\n<p>阶段一：</p>\n<ul>\n<li>用户进程调用select，指定要监听的FD集合</li>\n<li>核监听FD对应的多个socket</li>\n<li>任意一个或多个socket数据就绪则返回readable</li>\n<li>此过程中用户进程阻塞</li>\n</ul>\n<p>阶段二：</p>\n<ul>\n<li>用户进程找到就绪的socket</li>\n<li>依次调用recvfrom读取数据</li>\n<li>内核将数据拷贝到用户空间</li>\n<li>用户进程处理数据</li>\n</ul>\n<p>当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p>\n<p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653898691736.png\" alt=\"1653898691736\"></p>\n<p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p>\n<ul>\n<li>select</li>\n<li>poll</li>\n<li>epoll</li>\n</ul>\n<p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p>\n<p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作。</p>\n<h3 id=\"2-5-网络模型-IO多路复用-select方式\"><a href=\"#2-5-网络模型-IO多路复用-select方式\" class=\"headerlink\" title=\"2.5 网络模型-IO多路复用-select方式\"></a>2.5 网络模型-IO多路复用-select方式</h3><p>select是Linux最早是由的I&#x2F;O多路复用技术：</p>\n<p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据，</p>\n<p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653900022580.png\" alt=\"1653900022580\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1658848028wmxtmguntitled.png\" alt=\"Untitled.png\"></p>\n<h3 id=\"2-6-网络模型-IO多路复用模型-poll模式\"><a href=\"#2-6-网络模型-IO多路复用模型-poll模式\" class=\"headerlink\" title=\"2.6 网络模型-IO多路复用模型-poll模式\"></a>2.6 网络模型-IO多路复用模型-poll模式</h3><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p>\n<p>IO流程：</p>\n<ul>\n<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>\n<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li>\n<li>内核遍历fd，判断是否就绪</li>\n<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>\n<li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li>\n</ul>\n<p><strong>与select对比：</strong></p>\n<ul>\n<li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li>\n<li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653900721427.png\" alt=\"1653900721427\"></p>\n<h3 id=\"2-7-网络模型-IO多路复用模型-epoll函数\"><a href=\"#2-7-网络模型-IO多路复用模型-epoll函数\" class=\"headerlink\" title=\"2.7 网络模型-IO多路复用模型-epoll函数\"></a>2.7 网络模型-IO多路复用模型-epoll函数</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">epoll_create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span>；<span class=\"token comment\">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">epoll_ctl</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> epfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> op<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">epoll_event</span> <span class=\"token operator\">*</span>event<span class=\"token punctuation\">)</span>；\n<span class=\"token keyword\">int</span> <span class=\"token function\">epoll_wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> epfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">epoll_event</span> <span class=\"token operator\">*</span> events<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> maxevents<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">1.</span> <span class=\"token keyword\">int</span> <span class=\"token function\">epoll_create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于<span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>中的第一个参数，给出最大监听的fd<span class=\"token operator\">+</span><span class=\"token number\">1</span>的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。\n当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看<span class=\"token operator\">/</span>proc<span class=\"token operator\">/</span>进程id<span class=\"token operator\">/</span>fd<span class=\"token operator\">/</span>，是能够看到这个fd的，所以在使用完epoll后，必须调用<span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>关闭，否则可能导致fd被耗尽。\n\n<span class=\"token number\">2.</span> <span class=\"token keyword\">int</span> <span class=\"token function\">epoll_ctl</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> epfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> op<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">epoll_event</span> <span class=\"token operator\">*</span>event<span class=\"token punctuation\">)</span>；\n函数是对指定描述符fd执行op操作。\n<span class=\"token operator\">-</span> epfd：是<span class=\"token function\">epoll_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>的返回值。\n<span class=\"token operator\">-</span> op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。\n<span class=\"token operator\">-</span> fd：是需要监听的fd（文件描述符）\n<span class=\"token operator\">-</span> epoll_event：是告诉内核需要监听什么事，<span class=\"token keyword\">struct</span> <span class=\"token class-name\">epoll_event</span>结构如下：\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">epoll_event</span> <span class=\"token punctuation\">&#123;</span>\n  __uint32_t events<span class=\"token punctuation\">;</span>  <span class=\"token comment\">/* Epoll events */</span>\n  <span class=\"token class-name\">epoll_data_t</span> data<span class=\"token punctuation\">;</span>  <span class=\"token comment\">/* User data variable */</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//events可以是以下几个宏的集合：</span>\nEPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；\nEPOLLOUT：表示对应的文件描述符可以写；\nEPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\nEPOLLERR：表示对应的文件描述符发生错误；\nEPOLLHUP：表示对应的文件描述符被挂断；\nEPOLLET： 将EPOLL设为边缘触发<span class=\"token punctuation\">(</span>Edge Triggered<span class=\"token punctuation\">)</span>模式，这是相对于水平触发<span class=\"token punctuation\">(</span>Level Triggered<span class=\"token punctuation\">)</span>来说的。\nEPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n<span class=\"token number\">3.</span> <span class=\"token keyword\">int</span> <span class=\"token function\">epoll_wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> epfd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">epoll_event</span> <span class=\"token operator\">*</span> events<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> maxevents<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n等待epfd上的io事件，最多返回maxevents个事件。\n参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建<span class=\"token function\">epoll_create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>时的size，参数timeout是超时时间（毫秒，<span class=\"token number\">0</span>会立即返回，<span class=\"token operator\">-</span><span class=\"token number\">1</span>将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回<span class=\"token number\">0</span>表示已超时。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>epoll模式是对select和poll的改进，它提供了三个函数：</p>\n<p>第一个是：eventpoll的函数，他内部包含两个东西</p>\n<p>一个是：</p>\n<p>1、红黑树-&gt; 记录的事要监听的FD</p>\n<p>2、一个是链表-&gt;一个链表，记录的是就绪的FD</p>\n<p>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，就是准备好了，现在就把fd把数据添加到list_head中去</p>\n<p>3、调用epoll_wait函数</p>\n<p>就去等待，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等， 如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量，用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据。</p>\n<p>小总结：</p>\n<p>select模式存在的三个问题：</p>\n<ul>\n<li>能监听的FD最大不超过1024</li>\n<li>每次select都需要把所有要监听的FD都拷贝到内核空间</li>\n<li>每次都要遍历所有FD来判断就绪状态</li>\n</ul>\n<p>poll模式的问题：</p>\n<ul>\n<li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li>\n</ul>\n<p>epoll模式中如何解决这些问题的？</p>\n<ul>\n<li><strong>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</strong></li>\n<li><strong>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</strong></li>\n<li><strong>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</strong></li>\n</ul>\n<h3 id=\"2-8、网络模型-epoll中的ET和LT\"><a href=\"#2-8、网络模型-epoll中的ET和LT\" class=\"headerlink\" title=\"2.8、网络模型-epoll中的ET和LT\"></a>2.8、网络模型-epoll中的ET和LT</h3><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p>\n<ul>\n<li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li>\n<li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li>\n</ul>\n<p>举个栗子：</p>\n<ul>\n<li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li>\n<li>客户端socket发送了2kb的数据</li>\n<li>服务端调用epoll_wait，得到通知说FD就绪</li>\n<li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li>\n</ul>\n<p>结论</p>\n<p>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知<br>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</p>\n<h3 id=\"2-9-网络模型-基于epoll的服务器端流程\"><a href=\"#2-9-网络模型-基于epoll的服务器端流程\" class=\"headerlink\" title=\"2.9 网络模型-基于epoll的服务器端流程\"></a>2.9 网络模型-基于epoll的服务器端流程</h3><p>我们来梳理一下这张图</p>\n<p>服务器启动以后，服务端会去调用epoll_create，创建一个epoll实例，epoll实例中包含两个数据</p>\n<p>1、红黑树（为空）：rb_root 用来去记录需要被监听的FD</p>\n<p>2、链表（为空）：list_head，用来存放已经就绪的FD</p>\n<p>创建好了之后，会去调用epoll_ctl函数，此函数会会将需要监听的数据添加到rb_root中去，并且对当前这些存在于红黑树的节点设置回调函数，当这些被监听的数据一旦准备完成，就会被调用，而调用的结果就是将红黑树的fd添加到list_head中去(但是此时并没有完成)</p>\n<p>3、当第二步完成后，就会调用epoll_wait函数，这个函数会去校验是否有数据准备完毕（因为数据一旦准备就绪，就会被回调函数添加到list_head中），在等待了一段时间后(可以进行配置)，如果等够了超时时间，则返回没有数据，如果有，则进一步判断当前是什么事件，如果是建立连接时间，则调用accept() 接受客户端socket，拿到建立连接的socket，然后建立起来连接，如果是其他事件，则把数据进行写出</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653902845082.png\" alt=\"1653902845082\"></p>\n<h3 id=\"3-0-、网络模型-信号驱动\"><a href=\"#3-0-、网络模型-信号驱动\" class=\"headerlink\" title=\"3.0 、网络模型-信号驱动\"></a>3.0 、网络模型-信号驱动</h3><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p>\n<p>阶段一：</p>\n<ul>\n<li>用户进程调用sigaction，注册信号处理函数</li>\n<li>内核返回成功，开始监听FD</li>\n<li>用户进程不阻塞等待，可以执行其它业务</li>\n<li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li>\n</ul>\n<p>阶段二：</p>\n<ul>\n<li>收到SIGIO回调信号</li>\n<li>调用recvfrom，读取</li>\n<li>内核将数据拷贝到用户空间</li>\n<li>用户进程处理数据</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653911776583.png\" alt=\"1653911776583\"></p>\n<p><strong>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</strong></p>\n<h4 id=\"3-0-1-异步IO\"><a href=\"#3-0-1-异步IO\" class=\"headerlink\" title=\"3.0.1 异步IO\"></a>3.0.1 异步IO</h4><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p>\n<p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653911877542.png\" alt=\"1653911877542\"></p>\n<h4 id=\"3-0-2-对比\"><a href=\"#3-0-2-对比\" class=\"headerlink\" title=\"3.0.2 对比\"></a>3.0.2 对比</h4><p>最后用一幅图，来说明他们之间的区别</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653912219712.png\" alt=\"1653912219712\"></p>\n<h3 id=\"3-1-、网络模型-Redis是单线程的吗？为什么使用单线程\"><a href=\"#3-1-、网络模型-Redis是单线程的吗？为什么使用单线程\" class=\"headerlink\" title=\"3.1 、网络模型-Redis是单线程的吗？为什么使用单线程\"></a>3.1 、网络模型-Redis是单线程的吗？为什么使用单线程</h3><p><strong>Redis到底是单线程还是多线程？</strong></p>\n<ul>\n<li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li>\n<li>如果是聊整个Redis，那么答案就是多线程</li>\n</ul>\n<p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p>\n<ul>\n<li>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li>\n<li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li>\n</ul>\n<p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p>\n<p><strong>为什么Redis要选择单线程？</strong></p>\n<ul>\n<li><strong>抛开持久化不谈，Redis是纯  内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</strong></li>\n<li><strong>多线程会导致过多的上下文切换，带来不必要的开销</strong></li>\n<li><strong>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</strong></li>\n</ul>\n<h3 id=\"3-2-、Redis的单线程模型-Redis单线程和多线程网络模型变更\"><a href=\"#3-2-、Redis的单线程模型-Redis单线程和多线程网络模型变更\" class=\"headerlink\" title=\"3.2 、Redis的单线程模型-Redis单线程和多线程网络模型变更\"></a>3.2 、Redis的单线程模型-Redis单线程和多线程网络模型变更</h3><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653982278727.png\" alt=\"1653982278727\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/v25a7ffda1371b515b5ba959cf926def52r.jpg\" alt=\"preview\"></p>\n<p>当我们的客户端想要去连接我们服务器，会去先到IO多路复用模型去进行排队，会有一个连接应答处理器，他会去接受读请求，然后又把读请求注册到具体模型中去，此时这些建立起来的连接，如果是客户端请求处理器去进行执行命令时，他会去把数据读取出来，然后把数据放入到client中， clinet去解析当前的命令转化为redis认识的命令，接下来就开始处理这些命令，从redis中的command中找到这些命令，然后就真正的去操作对应的数据了，当数据操作完成后，会去找到命令回复处理器，再由他将数据写出。</p>\n<h2 id=\"3、Redis通信协议-RESP协议\"><a href=\"#3、Redis通信协议-RESP协议\" class=\"headerlink\" title=\"3、Redis通信协议-RESP协议\"></a>3、Redis通信协议-RESP协议</h2><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p>\n<p>客户端（client）向服务端（server）发送一条命令</p>\n<p>服务端解析并执行命令，返回响应结果给客户端</p>\n<p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p>\n<p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p>\n<p>Redis 1.2版本引入了RESP协议</p>\n<p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p>\n<p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</p>\n<p>但目前，默认使用的依然是RESP2协议，也是我们要学习的协议版本（以下简称RESP）。</p>\n<p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p>\n<p>单行字符串：首字节是 ‘**+**’ ，后面跟上单行字符串，以CRLF（ “\\r\\n” ）结尾。例如返回”OK”： “+OK\\r\\n”</p>\n<p>错误（Errors）：首字节是 ‘**-**’ ，与单行字符串格式一样，只是字符串是异常信息，例如：”-Error message\\r\\n”</p>\n<p>数值：首字节是 ‘**:**’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：”:10\\r\\n”</p>\n<p>多行字符串：首字节是 ‘**$**’ ，表示二进制安全的字符串，最大支持512MB：</p>\n<p>如果大小为0，则代表空字符串：”$0\\r\\n\\r\\n”</p>\n<p>如果大小为-1，则代表不存在：”$-1\\r\\n”</p>\n<p>数组：首字节是 ‘*****’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653982993020.png\" alt=\"1653982993020\"></p>\n<h3 id=\"3-1、Redis通信协议-基于Socket自定义Redis的客户端\"><a href=\"#3-1、Redis通信协议-基于Socket自定义Redis的客户端\" class=\"headerlink\" title=\"3.1、Redis通信协议-基于Socket自定义Redis的客户端\"></a>3.1、Redis通信协议-基于Socket自定义Redis的客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token class-name\">Socket</span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token class-name\">PrintWriter</span> writer<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token class-name\">BufferedReader</span> reader<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 1.建立连接</span>\n            <span class=\"token class-name\">String</span> host <span class=\"token operator\">=</span> <span class=\"token string\">\"192.168.150.101\"</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> port <span class=\"token operator\">=</span> <span class=\"token number\">6379</span><span class=\"token punctuation\">;</span>\n            s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Socket</span><span class=\"token punctuation\">(</span>host<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 2.获取输出流、输入流</span>\n            writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PrintWriter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OutputStreamWriter</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">getOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UTF_8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UTF_8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// 3.发出请求</span>\n            <span class=\"token comment\">// 3.1.获取授权 auth 123321</span>\n            <span class=\"token function\">sendRequest</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"auth\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"123321\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> <span class=\"token function\">handleResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"obj = \"</span> <span class=\"token operator\">+</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// 3.2.set name 虎哥</span>\n            <span class=\"token function\">sendRequest</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"set\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"虎哥\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 4.解析响应</span>\n            obj <span class=\"token operator\">=</span> <span class=\"token function\">handleResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"obj = \"</span> <span class=\"token operator\">+</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// 3.2.set name 虎哥</span>\n            <span class=\"token function\">sendRequest</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 4.解析响应</span>\n            obj <span class=\"token operator\">=</span> <span class=\"token function\">handleResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"obj = \"</span> <span class=\"token operator\">+</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\">// 3.2.set name 虎哥</span>\n            <span class=\"token function\">sendRequest</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mget\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"num\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"msg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 4.解析响应</span>\n            obj <span class=\"token operator\">=</span> <span class=\"token function\">handleResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"obj = \"</span> <span class=\"token operator\">+</span> obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// 5.释放连接</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>reader <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>writer <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> writer<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">handleResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 读取首字节</span>\n        <span class=\"token keyword\">int</span> prefix <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 判断数据类型标示</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token char\">'+'</span><span class=\"token operator\">:</span> <span class=\"token comment\">// 单行字符串，直接读一行</span>\n                <span class=\"token keyword\">return</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token char\">'-'</span><span class=\"token operator\">:</span> <span class=\"token comment\">// 异常，也读一行</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token char\">':'</span><span class=\"token operator\">:</span> <span class=\"token comment\">// 数字</span>\n                <span class=\"token keyword\">return</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseLong</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token char\">'$'</span><span class=\"token operator\">:</span> <span class=\"token comment\">// 多行字符串</span>\n                <span class=\"token comment\">// 先读长度</span>\n                <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token comment\">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span>\n                <span class=\"token keyword\">return</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token char\">'*'</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">readBulkString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"错误的数据格式！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">readBulkString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 获取数组大小</span>\n        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">// 定义集合，接收多个元素</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 遍历，依次读取每个元素</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">handleResponse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">// set name 虎哥</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sendRequest</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"*\"</span> <span class=\"token operator\">+</span> args<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg <span class=\"token operator\">:</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            writer<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"$\"</span> <span class=\"token operator\">+</span> arg<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UTF_8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            writer<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        writer<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-2、Redis内存回收-过期key处理\"><a href=\"#3-2、Redis内存回收-过期key处理\" class=\"headerlink\" title=\"3.2、Redis内存回收-过期key处理\"></a>3.2、Redis内存回收-过期key处理</h3><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br>我们可以通过修改配置文件来设置Redis的最大内存：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653983341150.png\" alt=\"1653983341150\"></p>\n<p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p>\n<p>内存过期策略</p>\n<p>在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间）：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653983366243.png\" alt=\"1653983366243\"></p>\n<p>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p>\n<p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653983423128.png\" alt=\"1653983423128\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653983606531.png\" alt=\"1653983606531\"></p>\n<p>这里有两个问题需要我们思考：<br>Redis是如何知道一个key是否过期呢？</p>\n<p>利用两个Dict分别记录key-value对及key-ttl对</p>\n<p>是不是TTL到期就立即删除了呢？</p>\n<p><strong>惰性删除</strong></p>\n<p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653983652865.png\" alt=\"1653983652865\"></p>\n<p><strong>周期删除</strong></p>\n<p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：<br>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW<br>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</p>\n<p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：<br>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW<br>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</p>\n<p>SLOW模式规则：</p>\n<ul>\n<li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li>\n<li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li>\n<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>\n<li>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>\n<li>FAST模式规则（过期key比例小于10%不执行 ）：</li>\n<li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li>\n<li>执行清理耗时不超过1ms</li>\n<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期<br>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>\n</ul>\n<p>小总结：</p>\n<p>RedisKey的TTL记录方式：</p>\n<p>在RedisDB中通过一个Dict记录每个Key的TTL时间</p>\n<p>过期key的删除策略：</p>\n<p>惰性清理：每次查找key时判断是否过期，如果过期则删除</p>\n<p>定期清理：定期抽样部分key，判断是否过期，如果过期则删除。<br>定期清理的两种模式：</p>\n<p><strong>SLOW模式执行频率默认为10，每次不超过25ms</strong></p>\n<p><strong>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</strong></p>\n<h3 id=\"3-3-Redis内存回收-内存淘汰策略\"><a href=\"#3-3-Redis内存回收-内存淘汰策略\" class=\"headerlink\" title=\"3.3 Redis内存回收-内存淘汰策略\"></a>3.3 Redis内存回收-内存淘汰策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653983978671.png\" alt=\"1653983978671\"></p>\n<p> 淘汰策略</p>\n<p>Redis支持8种不同策略来选择要删除的key：</p>\n<ul>\n<li><strong>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</strong></li>\n<li><strong>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</strong></li>\n<li><strong>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</strong></li>\n<li><strong>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</strong></li>\n<li><strong>allkeys-lru： 对全体key，基于LRU算法进行淘汰</strong></li>\n<li><strong>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</strong></li>\n<li><strong>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</strong></li>\n<li><strong>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</strong><br>比较容易混淆的有两个：<ul>\n<li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li>\n<li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li>\n</ul>\n</li>\n</ul>\n<p>Redis的数据都会被封装为RedisObject结构：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984029506.png\" alt=\"1653984029506\"></p>\n<p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p>\n<ul>\n<li>生成0~1之间的随机数R</li>\n<li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li>\n<li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li>\n<li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li>\n</ul>\n<p>最后用一副图来描述当前的这个流程吧</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/1653984085095.png\" alt=\"1653984085095\"></p>\n","text":"Redis原理篇1、原理篇-Redis数据结构1.1 动态字符串我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。 不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：获取字符串...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","count":7,"path":"api/tags/学习笔记.json"},{"name":"Redis","slug":"Redis","count":2,"path":"api/tags/Redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Redis%E5%8E%9F%E7%90%86%E7%AF%87\"><span class=\"toc-text\">Redis原理篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8E%9F%E7%90%86%E7%AF%87-Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1、原理篇-Redis数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">1.1 动态字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-intset\"><span class=\"toc-text\">1.2 intset</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-Dict\"><span class=\"toc-text\">1.3 Dict</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-ZipList\"><span class=\"toc-text\">1.4 ZipList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-ZipList%E7%9A%84%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.5 ZipList的连锁更新问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-QuickList\"><span class=\"toc-text\">1.6 QuickList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-SkipList\"><span class=\"toc-text\">1.7 SkipList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-8-RedisObject\"><span class=\"toc-text\">1.8 RedisObject</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-9-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-String\"><span class=\"toc-text\">1.9 基本类型-String</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-0-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-List\"><span class=\"toc-text\">2.0 基本类型-List</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-Set\"><span class=\"toc-text\">2.1 基本类型-Set</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-ZSET\"><span class=\"toc-text\">2.2、基本类型-ZSET</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-Hash\"><span class=\"toc-text\">2.3、基本类型-Hash</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%8E%9F%E7%90%86%E7%AF%87-Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2、原理篇-Redis网络模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">2.1 用户空间和内核态空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9EIO\"><span class=\"toc-text\">2.2.网络模型-阻塞IO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9EIO\"><span class=\"toc-text\">2.3 网络模型-非阻塞IO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">2.4 网络模型-IO多路复用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.5 网络模型-IO多路复用-select方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B-poll%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.6 网络模型-IO多路复用模型-poll模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-7-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B-epoll%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2.7 网络模型-IO多路复用模型-epoll函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-8%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-epoll%E4%B8%AD%E7%9A%84ET%E5%92%8CLT\"><span class=\"toc-text\">2.8、网络模型-epoll中的ET和LT</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-9-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">2.9 网络模型-基于epoll的服务器端流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-0-%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8\"><span class=\"toc-text\">3.0 、网络模型-信号驱动</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-0-1-%E5%BC%82%E6%AD%A5IO\"><span class=\"toc-text\">3.0.1 异步IO</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-0-2-%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">3.0.2 对比</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">3.1 、网络模型-Redis是单线程的吗？为什么使用单线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E3%80%81Redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%9B%B4\"><span class=\"toc-text\">3.2 、Redis的单线程模型-Redis单线程和多线程网络模型变更</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-RESP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">3、Redis通信协议-RESP协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1%E3%80%81Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE-%E5%9F%BA%E4%BA%8ESocket%E8%87%AA%E5%AE%9A%E4%B9%89Redis%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">3.1、Redis通信协议-基于Socket自定义Redis的客户端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2%E3%80%81Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6-%E8%BF%87%E6%9C%9Fkey%E5%A4%84%E7%90%86\"><span class=\"toc-text\">3.2、Redis内存回收-过期key处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">3.3 Redis内存回收-内存淘汰策略</span></a></li></ol></li></ol></li></ol>","author":{"name":"JuneQQQ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/JuneQQQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_46925850","juejin":"https://juejin.cn/user/3927934338357197","customs":{}}},"mapped":true,"prev_post":{"title":"Redis基础","uid":"b6845422ba4775a7cab0c414606e3ecd","slug":"Redis基础","date":"2022-09-30T09:26:18.000Z","updated":"2022-09-30T09:28:56.369Z","comments":true,"path":"api/articles/Redis基础.json","keywords":null,"cover":[],"text":" Linux 基础环境配置 配置gcc # 检查是否安装 gcc --version # 未安装的话 yum install centos-release-scl scl-utils-build yum install -y devtoolset-8-toolchain scl ...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","count":7,"path":"api/tags/学习笔记.json"},{"name":"Redis","slug":"Redis","count":2,"path":"api/tags/Redis.json"}],"author":{"name":"JuneQQQ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/JuneQQQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_46925850","juejin":"https://juejin.cn/user/3927934338357197","customs":{}}}},"next_post":{"title":"浅析HTTP发展历程","uid":"0078db1e0e91966be57f6a3288ece9dc","slug":"浅析HTTP发展历程","date":"2022-09-27T14:15:15.000Z","updated":"2022-09-27T14:16:23.768Z","comments":true,"path":"api/articles/浅析HTTP发展历程.json","keywords":null,"cover":[],"text":"浅析HTTP发展历程HTTP0.9 - 诞生最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。 HTTP&#x2F;0.9 极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"JuneQQQ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/JuneQQQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_46925850","juejin":"https://juejin.cn/user/3927934338357197","customs":{}}}}}