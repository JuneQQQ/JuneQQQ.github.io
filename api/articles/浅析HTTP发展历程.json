{"title":"浅析HTTP发展历程","uid":"0078db1e0e91966be57f6a3288ece9dc","slug":"浅析HTTP发展历程","date":"2022-09-27T14:15:15.000Z","updated":"2022-09-27T14:16:23.768Z","comments":true,"path":"api/articles/浅析HTTP发展历程.json","keywords":null,"cover":[],"content":"<h2 id=\"浅析HTTP发展历程\"><a href=\"#浅析HTTP发展历程\" class=\"headerlink\" title=\"浅析HTTP发展历程\"></a>浅析HTTP发展历程</h2><h3 id=\"HTTP0-9-诞生\"><a href=\"#HTTP0-9-诞生\" class=\"headerlink\" title=\"HTTP0.9 - 诞生\"></a>HTTP0.9 - 诞生</h3><p>最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。 HTTP&#x2F;0.9 极其简单：请求由单行指令构成，以唯一可用方法<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET\"><code>GET</code></a>开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">GET /mypage.html<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>响应也极其简单的：只包含响应文档本身。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;HTML&gt;\n这是一个非常简单的 HTML 页面\n&lt;&#x2F;HTML&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>跟后来的版本不同，HTTP&#x2F;0.9 的响应内容并不包含 HTTP 头，这意味着只有 HTML 文件可以传送，无法传输其他类型的文件；也没有状态码或错误代码：一旦出现问题，一个特殊的包含问题描述信息的 HTML 文件将被发回，供人们查看。</p>\n<h3 id=\"HTTP1-0-构建可扩展性\"><a href=\"#HTTP1-0-构建可扩展性\" class=\"headerlink\" title=\"HTTP1.0 - 构建可扩展性\"></a>HTTP1.0 - 构建可扩展性</h3><p>一个典型的请求看起来就像这样：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/mypage.html</span> <span class=\"token http-version property\">HTTP/1.0</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">User-Agent</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">NCSA_Mosaic/2.0 (Windows 3.1)</span></span>\n\n200 OK\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Tue, 15 Nov 1994 08:12:31 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Server</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">CERN/3.0 libwww/2.17</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html</span></span>\n<span class=\"token text-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>HTML</span><span class=\"token punctuation\">></span></span>\n一个包含图片的页面\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>IMG</span> <span class=\"token attr-name\">SRC</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/myimage.gif<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>HTML</span><span class=\"token punctuation\">></span></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>接下来是第二个连接，请求获取图片：</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/myimage.gif</span> <span class=\"token http-version property\">HTTP/1.0</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">User-Agent</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">NCSA_Mosaic/2.0 (Windows 3.1)</span></span>\n\n200 OK\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Tue, 15 Nov 1994 08:12:32 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Server</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">CERN/3.0 libwww/2.17</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/gif</span></span>\n(这里是图片内容)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"HTTP1-1-标准化的协议\"><a href=\"#HTTP1-1-标准化的协议\" class=\"headerlink\" title=\"HTTP1.1 - 标准化的协议\"></a>HTTP1.1 - 标准化的协议</h3><ul>\n<li>持久连接：HTTP&#x2F;1.1 最大的变化就是引入了持久连接（persistent connection），在HTTP&#x2F;1.1中默认开启 Connection: keep-alive，即TCP连接默认不关闭，可以被多个请求复用，<strong>但是这里存在队头阻塞问题</strong></li>\n<li>缓存处理：HTTP&#x2F;1.0 使用 Pragma:no-cache + Last-Modified&#x2F;If-Modified-Since来作为缓存判断的标准；HTTP&#x2F;1.1 引入了更多的缓存控制策略：Cache-Control、Etag&#x2F;If-None-Match等</li>\n<li>范围请求：HTTP&#x2F;1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接，支持断点续传</li>\n<li>错误状态管理：HTTP&#x2F;1.1新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>HTTP&#x2F;1.1 的持久连接和管道机制允许复用TCP连接，在一个TCP连接中，也可以同时发送多个请求，但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应，才会处理下一个回应。比如客户端需要A、B两个资源，管道机制允许浏览器同时发出A请求和B请求，但服务器还是按照顺序，先回应A请求，完成后再回应B请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为”队头阻塞(Head-of-line blocking)”。这个问题到HTTP3才被完全解决。</p></blockquote>\n<h3 id=\"HTTP2-0-为了更优异的表现\"><a href=\"#HTTP2-0-为了更优异的表现\" class=\"headerlink\" title=\"HTTP2.0 - 为了更优异的表现\"></a>HTTP2.0 - 为了更优异的表现</h3><p>这些年来，网页愈渐变得的复杂，甚至演变成了独有的应用，可见媒体的播放量，增进交互的脚本大小也增加了许多：更多的数据通过 HTTP 请求被传输。HTTP&#x2F;1.1 链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是 5 到 8 个），带来的成本和复杂性堪忧。比如，HTTP 管线化（pipelining）就成为了 Web 开发的负担。</p>\n<p>在 2010 年到 2015 年，谷歌通过实践了一个实验性的 <strong>SPDY</strong> 协议，证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题。明确了响应数量的增加和解决复杂的数据传输，<strong>SPDY</strong> 成为了 HTTP&#x2F;2 协议的基础。HTTP2的主要特点如下：</p>\n<ul>\n<li><strong>二进制分帧</strong>：HTTP&#x2F;1.1的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制；HTTP&#x2F;2 头信息和数据体都是二进制，统称为“帧”：头信息帧和数据帧；</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/image20220927172414723.png\" alt=\"image-20220927172414723\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p><strong>多路复用</strong>：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p>\n<p>而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http&#x2F;2 连接发起多重的请求-响应消息。有了新的分帧机制后，http&#x2F;2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p>\n<p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2b66564f030cc9088f0eb75b3c9d95c331440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n</li>\n<li><p><strong>头部压缩</strong>：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息压缩后再发送（SPDY 使用的是通用的DEFLATE 算法，而 HTTP&#x2F;2 则使用了专门为首部压缩而设计的 HPACK 算法）。；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>\n<p>  例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p>\n</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v21573194744d005dd110bbeac3a9b52461440w.jpg\" alt=\"img\"></p>\n<ul>\n<li><strong>服务端推送</strong>：HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</li>\n</ul>\n<h3 id=\"穿插一下HTTPS\"><a href=\"#穿插一下HTTPS\" class=\"headerlink\" title=\"穿插一下HTTPS\"></a>穿插一下HTTPS</h3><p>HTTPS可以说是安全版的HTTP，HTTPS基于安全SSL&#x2F;TLS（安全套接层Secure Sockets Layer&#x2F;安全传输层Transport Layer Security）层，即在传统的HTTP和TCP之间加了一层用于加密解密的SSL&#x2F;TLS层。HTTP默认使用80端口，HTTPS默认使用443端口。</p>\n<ul>\n<li><p>不使用SSL&#x2F;TLS的HTTP通信，所有信息明文传播，会带来三大风险；</p>\n</li>\n<li><p>窃听风险：第三方可以获取通信内容；篡改风险：第三方可以修改通信内容；冒充风险：第三方可以冒充他人进行通信。SSL&#x2F;TLS协议是为了解决这三大风险而设计的，以期达到；</p>\n</li>\n<li><p>信息加密传输：第三方无法窃听；校验机制：一旦被篡改，通信双方会立刻发现；身份证书：防止身份被冒充。</p>\n</li>\n</ul>\n<p><strong>HTTPS通信过程</strong></p>\n<ol>\n<li>TCP的3次握手</li>\n<li><strong>TLS连接</strong></li>\n<li>HTTP请求和响应</li>\n</ol>\n<p>共计3RTT，速度略慢，所以HTTP3将对此进行优化</p>\n<p>以下三幅图不同程度描述了HTTPS通信过程：</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/formatpng.png\" style=\"zoom:50%;\" />\n\n<p>这里是TLS1.2，请注意</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/image20211224114502634.png\" alt=\"image-20211224114502634\" style=\"zoom: 33%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/image202111021426215222235.png\" alt=\"image-202111021426215222235\"  />\n\n\n\n<h3 id=\"HTTP3-0-为什么更快的速度\"><a href=\"#HTTP3-0-为什么更快的速度\" class=\"headerlink\" title=\"HTTP3.0 - 为什么更快的速度\"></a>HTTP3.0 - 为什么更快的速度</h3><h4 id=\"Quick是什么？\"><a href=\"#Quick是什么？\" class=\"headerlink\" title=\"Quick是什么？\"></a>Quick是什么？</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><pre><code>    QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的互联网传输层协议。我们知道，TCP/IP协议族是互联网的基础。其中传输层协议包括TCP和UDP协议。与[TCP协议](https://baike.baidu.com/item/TCP协议/8988699?fromModule=lemma_inlink)相比，UDP更为轻量，但是错误校验也要少得多。这意味着UDP往往效率更高（不经常跟服务器端通信查看数据包是否送达或者按序），但是可靠性比不上TCP。通常游戏、流媒体以及VoIP等应用均采用UDP，而网页、邮件、远程登录等大部分的应用均采用TCP。\n    \n                                                     \t\t\t\t\t\t\t————————摘自百度百科\n</code></pre></blockquote>\n<img src=\"https://pic4.zhimg.com/v2-d61a62fdfb08ed3882e1018136ce6b2f_r.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>从协议栈可以看出：QUIC &#x3D; HTTP&#x2F;2 + TLS + UDP</p>\n<h4 id=\"数据包格式\"><a href=\"#数据包格式\" class=\"headerlink\" title=\"数据包格式\"></a>数据包格式</h4><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v260231adb6c7014c7f043712839f77ab51440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n<p>由 header 和 data 两部分组成。</p>\n<p>header 是明文的，包含 4 个字段：<code>Flags</code>、<code>Connection ID</code>、<code>QUIC Version</code>、<code>Packet Number</code>；</p>\n<p>data 是加密的，可以包含 1 个或多个 frame，每个 frame 又分为 type 和 payload，其中 payload 就是应用数据；</p>\n<p>数据帧有很多类型：<code>Stream</code>、<code>ACK</code>、<code>Padding</code>、<code>Window_Update</code>、<code>Blocked</code> 等，这里重点介绍下用于传输应用数据的 <code>Stream</code> 帧。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2f1cb88ac186e851a724a85dbd4f3de011440w.jpg\" alt=\"img\"></p>\n<p><strong>Frame Type：</strong> 帧类型，占用 1 个字节</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2eb52f6d7f4d12a2599085f62f92401621440w.jpg\" alt=\"img\"></p>\n<p>（1）Bit7：必须设置为 1，表示 Stream 帧</p>\n<p>（2）Bit6：如果设置为 1，表示发送端在这个 stream 上已经结束发送数据，流将处于半关闭状态</p>\n<p>（3）Bit5：如果设置为 1，表示 Stream 头中包含 Data length 字段</p>\n<p>（4）Bit432：表示 offset 的长度。000 表示 0 字节，001 表示 2 字节，010 表示 3 字节，以此类推</p>\n<p>（5）Bit10：表示 Stream ID 的长度。00 表示 1 字节，01 表示 2 字节，10 表示 3 字节，11 表示 4 字节</p>\n<p><strong>Stream ID：</strong> 流 ID，用于标识数据包所属的流。后面的流量控制和多路复用会涉及到</p>\n<p><strong>Offset：</strong>偏移量，表示该数据包在整个数据中的偏移量，用于数据排序。</p>\n<p><strong>Data Length：</strong> 数据长度，占用 2 个字节，表示实际应用数据的长度</p>\n<p><strong>Data：</strong> 实际的应用数据</p>\n<h4 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h4><p>先分析下 HTTPS 的握手过程，包含 TCP 握手和 TLS 握手，TCP 握手：</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v21fb94488942494ec9425ecf6682ed6e11440w20220927175.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>从图中可以看出，TCP 握手需要 2 个 RTT。</p>\n<p>TLS 握手：密钥协商（1.3 版本）</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v286cc5e2cf1b509083759b9c22800e2a71440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n<p>从图中可以看出，TLS 握手需要 1 个 RTT，也就是 1 次 RTT 就把通信密钥协商好了，这是怎么做到的？</p>\n<p>（1）客户端：生成随机数 a，选择公开的大数 G 和 P，计算 A&#x3D;a*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p>\n<p>（2）服务器：生成随机数 b，计算 B&#x3D;b*G%P，将 B 发送给客户端，也就是 Server Hello 消息</p>\n<p>（3）客户端：使用 ECDH 算法生成通信密钥 KEY &#x3D; a<em>B &#x3D; a</em>b*G%P</p>\n<p>（4）服务器：使用 ECDH 算法生成通信密钥 KEY &#x3D; b<em>A &#x3D; b</em>a*G%P</p>\n<p>所以，这里的关键就是 ECDH 算法，a 和 b 是客户端和服务器的私钥，是不公开的，而其他参数是公开的。ECDH 算法有个非常重要的特征：即使知道 A、G、P，通过 A &#x3D; a*G%P 公式也是无法推到出 a 的，保证了私钥的安全性。</p>\n<p>综上所述，HTTPS 建立连接需要 3 个 RTT，由于 QUIC 的握手是基于 TLS1.3 实现的，所以首次建立连接时也是需要 1 次 RTT，那 QUIC 是如何做到 0-RTT 握手的呢？</p>\n<h4 id=\"如何做到0RTT握手？\"><a href=\"#如何做到0RTT握手？\" class=\"headerlink\" title=\"如何做到0RTT握手？\"></a>如何做到0RTT握手？</h4><p>其实原理很简单：客户端缓存了 ServerConfig（B&#x3D;b*G%P），下次建连直接使用缓存数据计算通信密钥：</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v23862b1eeb75898f4f32de223b6123ddb1440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>（1）客户端：生成随机数 c，选择公开的大数 G 和 P，计算 A&#x3D;c*G%P，将 A 和 G 发送给服务器，也就是 Client Hello 消息</p>\n<p>（2）客户端：客户端直接使用缓存的 ServerConfig 计算通信密钥 KEY &#x3D; c<em>B &#x3D; c</em>b*G%P，加密发送应用数据</p>\n<p>（3）服务器：根据 Client Hello 消息计算通信密钥 KEY &#x3D; b<em>A &#x3D; b</em>c*G%P</p>\n<p>也就是说，客户端不需要经过握手就可以发送应用数据，这就是 0-RTT 握手。再来思考一个问题：假设攻击者记录下所有的通信数据和公开参数（A1&#x3D;a<em>G%P，A2&#x3D;c</em>G%P，……），一旦服务器的随机数 b（私钥）泄漏了，那之前通信的所有数据就都可以破解了。</p>\n<p>为了解决这个问题，需要为每次会话都创建一个新的通信密钥，来保证前向安全性</p>\n<h4 id=\"可靠传输\"><a href=\"#可靠传输\" class=\"headerlink\" title=\"可靠传输\"></a>可靠传输</h4><p>QUIC 是基于 UDP 协议的，而 UDP 是不可靠传输协议，那 QUIC 是如何实现可靠传输的呢？</p>\n<p>可靠传输有 2 个重要特点：</p>\n<p>（1）完整性：发送端发出的数据包，接收端都能收到</p>\n<p>（2）有序性：接收端能按序组装数据包，解码得到有效的数据</p>\n<p>问题 1：发送端怎么知道发出的包是否被接收端收到了？</p>\n<p>解决方案：通过包号（PKN）和确认应答（SACK）</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2aace93419dd55c73ab4b5fd2976e13751440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>（1）客户端：发送 3 个数据包给服务器（PKN &#x3D; 1，2，3）</p>\n<p>（2）服务器：通过 SACK 告知客户端已经收到了 1 和 3，没有收到 2</p>\n<p>（3）客户端：重传第 2 个数据包（PKN&#x3D;4）</p>\n<p>由此可以看出，QUIC 的数据包号是单调递增的。也就是说，之前发送的数据包（PKN&#x3D;2）和重传的数据包（PKN&#x3D;4），虽然数据一样，但包号不同。</p>\n<p>问题 2：既然包号是单调递增的，那接收端怎么保证数据的有序性呢？</p>\n<p>解决方案：通过数据偏移量 offset</p>\n<p>每个数据包都有一个 offset 字段，表示在整个数据中的偏移量。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2e6abef5bc9316fd87905a5e97b5470501440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>接收端根据 offset 字段就可以对异步到达的数据包进行排序了。为什么 QUIC 要将 PKN 设计为单调递增？解决 TCP 的重传歧义问题：</p>\n<p>由于原始包和重传包的序列号是一样的，客户端不知道服务器返回的 ACK 包到底是原始包的，还是重传包的。但 QUIC 的原始包和重传包的序列号是不同的，也就可以判断 ACK 包的归属。</p>\n<h4 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a><strong>流量控制</strong></h4><p>和 TCP 一样，QUIC 也是利用滑动窗口机制实现流量控制：</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v22b659a36da1993c1a65bed48306069971440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>发送端的窗口大小由接收端告知，包括发送窗口和可用窗口，如果发送端收到了接收端的 ACK 确认应答（比如 ACK 36），那整个窗口就会向右滑动，发送新的数据包。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v262c627de56caf4617f97628215c4fa031440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>和 TCP 不同的是，QUIC 的滑动窗口分为 Connection 和 Stream 两种级别。Connection 流量控制：规定了所有数据流的总窗口大小；Stream 流量控制：规定了每个流的窗口大小。</p>\n<p>假设现在有 3 个 Stream，滑动窗口分别如下：</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2a5f95afac0935ae11f4672d3fdf9bf3e1440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>则整个 Connection 的可用窗口大小为：20+30+10 &#x3D; 60</p>\n<h4 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h4><p>拥塞控制是通过拥塞窗口限制发送方的数据量，避免整个网络发生拥塞。那拥塞窗口（cwnd）和滑动窗口（发送窗口：swnd，接收窗口：rwnd）有什么关系呢？</p>\n<p>swnd &#x3D; min（cwnd，rwnd）</p>\n<p>也就是说，发送窗口的大小是由接收窗口和拥塞窗口共同决定的。那拥塞窗口的大小是如何计算的？通过 4 个拥塞控制算法：慢启动、拥塞避免、拥塞发生、快速恢复</p>\n<h5 id=\"1-慢启动\"><a href=\"#1-慢启动\" class=\"headerlink\" title=\"1.慢启动\"></a>1.慢启动</h5><p>初始拥塞窗口大小 cwnd&#x3D;1，也就是可以传输 1 个 MDS（Max Datagram Size）大小的数据包，一般网卡允许传输的最大数据单元 MTU 的大小是 1500 字节。对于 UDP 数据报而言：MDS &#x3D; 1500（MTU）- 20（IP 首部）- 8（UDP 首部） &#x3D; 1472 字节</p>\n<p><strong>慢启动算法</strong>： 当发送方每收到一个 ACK，拥塞窗口就加 1（cwnd++）</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v254d7f3cc6ec67a9ae47fa5dfa3fccfc01440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>由此可以看出，慢启动阶段，拥塞窗口呈指数增长，那增长到多少是个头？</p>\n<p>有一个上限值：ssthresh（slow start threshold），从源码看，这个值是 2000 * MDS</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const QuicPacketCount kDefaultMaxCongestionWindowPackets &#x3D; 2000;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用慢启动算法</li>\n<li>当 <strong>cwnd &gt;&#x3D; ssthresh</strong> 时，使用拥塞避免算法</li>\n</ul>\n<h5 id=\"2-拥塞避免\"><a href=\"#2-拥塞避免\" class=\"headerlink\" title=\"2.拥塞避免\"></a>2.拥塞避免</h5><p>当拥塞窗口大小超过慢启动上限后，就会进入拥塞避免阶段。</p>\n<p><strong>拥塞避免算法：</strong> 当发送方每收到一个 ACK，拥塞窗口就加 1&#x2F;cwnd</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v21072c63fd6e97e671affe2d9346c38361440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>假设现在的 cwnd&#x3D;8，可以发送 8 个数据包，当收到这 8 个包的 ACK 时，拥塞窗口才会加 1，由此可知，在拥塞避免阶段，拥塞窗口是线性增长的。</p>\n<p>那啥时候是个头呢？不管，让它继续增长，直到网络发生拥塞，出现丢包，这时就会触发重传机制，进入拥塞发生阶段</p>\n<h5 id=\"3-拥塞发生\"><a href=\"#3-拥塞发生\" class=\"headerlink\" title=\"3.拥塞发生\"></a>3.拥塞发生</h5><p>重传有 2 种：超时重传和快速重传</p>\n<p>如果发生超时重传，使用的拥塞发生算法为：</p>\n<ul>\n<li>ssthresh &#x3D; cwnd &#x2F; 2</li>\n<li>cwnd &#x3D; 1</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2dcefc32fcbaca9acf5a347580b56ff3c1440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>重新使用慢启动和拥塞避免算法增加拥塞窗口的大小。</p>\n<p>如果发生快速重传（发送方收到 3 个相同的 ACK），使用的拥塞发生算法为：</p>\n<ul>\n<li>cwnd &#x3D; cwnd &#x2F; 2</li>\n<li>ssthresh &#x3D; cwnd</li>\n</ul>\n<p>接下来就会进入快速恢复阶段。</p>\n<h5 id=\"4-快速恢复\"><a href=\"#4-快速恢复\" class=\"headerlink\" title=\"4.快速恢复\"></a>4.快速恢复</h5><p>快速恢复算法：cwnd &#x3D; ssthresh + 3（因为收到 3 个 ACK），然后进入拥塞避免阶段。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v29158217fe2e02f6b17a29aadf649cdd21440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<h5 id=\"5-拥塞控制常见算法\"><a href=\"#5-拥塞控制常见算法\" class=\"headerlink\" title=\"5.拥塞控制常见算法\"></a>5.拥塞控制常见算法</h5><ul>\n<li>New Reno：基于丢包检测</li>\n<li>CUBIC：基于丢包检测</li>\n<li>BBR：基于网络带宽</li>\n</ul>\n<p>和 TCP 不同的是，QUIC 是在用户空间实现的拥塞控制，可以非常灵活的设置，甚至可以为每一个请求都设置一种拥塞控制算法。</p>\n<h4 id=\"解决队头阻塞\"><a href=\"#解决队头阻塞\" class=\"headerlink\" title=\"解决队头阻塞\"></a>解决队头阻塞</h4><p>多路复用是 HTTP&#x2F;2 的主要特性之一，但 HTTP&#x2F;3 的多路复用不完全和2相同。</p>\n<p>概念：单条 TCP 连接上可以同时发送多个 HTTP 请求，解决了 HTTP1.1 中单个连接 1 次只能发送 1 个请求的性能瓶颈。HTTP&#x2F;2 能实现多路复用的根本原因是采用了二进制帧格式的数据结构。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v29ec2f3b580d86711ce10bf983705e0a51440w.jpg\" alt=\"img\"></p>\n<ul>\n<li>Length：表示 Payload 的长度</li>\n<li>Type：表示帧类型</li>\n<li>Flags：帧标识</li>\n<li>Stream ID：数据帧所属的流</li>\n<li>Payload：应用数据，长度由 Length 字段指定</li>\n</ul>\n<p>一个请求就对应一条流，通过 Stream ID 就可以判断该数据帧属于哪个请求，假设有 A 和 B 两个请求，对应的 Stream ID 分别为 1 和 2，那这个 TCP 连接上传输的数据大概如下：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v233cc6b4531a4de38b94da1b2a7b6ee8a1440w.jpg\" alt=\"img\"></p>\n<p>虽然在 HTTP 应用层，可以同时发送多个请求，但是在 TCP 传输层，仍然只有 1 个滑动窗口来发送这些数据包，考虑下面的情形：</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v20454bee543863c36908765244b989a561440w.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>客户端发送的 5 个数据包（56789）服务器都收到了，并且回应了 5 个 ACK，但是第 5 个数据包的 ACK 丢失了，导致客户端的发送窗口无法向前移动，也就无法发送新的数据，这就是 TCP 层的队头阻塞问题。</p>\n<p>HTTP&#x2F;2 虽然通过多路复用解决了 HTTP 层的队头阻塞，但仍然存在 TCP 层的队头阻塞。那 QUIC 是如何解决 TCP 层的队头阻塞问题的呢？其实很简单，HTTP&#x2F;2 之所以存在 TCP 层的队头阻塞，是因为所有请求流都共享一个滑动窗口，那如果给每个请求流都分配一个独立的滑动窗口，是不是就可以解决这个问题了？</p>\n<p>QUIC 就是这么做的：</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2b5a52474167933083a90ff8baa0400051440w.jpg\" alt=\"img\"></p>\n<p>A 请求流上的丢包不会影响 B 请求流上的数据发送。但是，对于每个请求流而言，也是存在队头阻塞问题的，也就是说，虽然 QUIC 解决了 TCP 层的队头阻塞，但仍然存在单条流上的队头阻塞。这就是 QUIC 声明的无队头阻塞的多路复用。</p>\n<h4 id=\"连接迁移\"><a href=\"#连接迁移\" class=\"headerlink\" title=\"连接迁移\"></a>连接迁移</h4><p>连接迁移：当客户端切换网络时，和服务器的连接并不会断开，仍然可以正常通信，对于 TCP 协议而言，这是不可能做到的。因为 TCP 的连接基于 4 元组：源 IP、源端口、目的 IP、目的端口，只要其中 1 个发生变化，就需要重新建立连接。但 QUIC 的连接是基于 64 位的 Connection ID，网络切换并不会影响 Connection ID 的变化，连接在逻辑上仍然是通的。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/27/v2f82f920a417188160d2354757db445671440w.jpg\" alt=\"img\"></p>\n<p>假设客户端先使用 IP1 发送了 1 和 2 数据包，之后切换网络，IP 变更为 IP2，发送了 3 和 4 数据包，服务器根据数据包头部的 Connection ID 字段可以判断这 4 个包是来自于同一个客户端。QUIC 能实现连接迁移的根本原因是底层使用 UDP 协议就是面向无连接的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://hungryturbo.com/HTTP3-explained/quic/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81QUIC.html#%E5%9B%9E%E9%A1%BEhttp-2\">为什么需要QUIC | HTTP&#x2F;3详解 (hungryturbo.com)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/405387352\">QUIC 协议详解 - 知乎 (zhihu.com)</a></li>\n<li><a href=\"https://www.zhihu.com/question/65900752\">http2是如何解决tcp的队首阻塞的？ - 知乎 (zhihu.com)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\">一文读懂 HTTP&#x2F;2 特性 - 知乎 (zhihu.com)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/140739394\">深入解读HTTP3的原理及应用 - 知乎 (zhihu.com)</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1464938\">详解HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2、HTTPS - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/89471776\">深入理解http2.0协议，看这篇就够了！ - 知乎 (zhihu.com)</a></li>\n</ul></blockquote>\n","feature":true,"text":"浅析HTTP发展历程HTTP0.9 - 诞生最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。 HTTP&#x2F;0.9 极其简单：请求由单行指令构成，以唯一可用方法GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%85%E6%9E%90HTTP%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B\"><span class=\"toc-text\">浅析HTTP发展历程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP0-9-%E8%AF%9E%E7%94%9F\"><span class=\"toc-text\">HTTP0.9 - 诞生</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP1-0-%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7\"><span class=\"toc-text\">HTTP1.0 - 构建可扩展性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP1-1-%E6%A0%87%E5%87%86%E5%8C%96%E7%9A%84%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">HTTP1.1 - 标准化的协议</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP2-0-%E4%B8%BA%E4%BA%86%E6%9B%B4%E4%BC%98%E5%BC%82%E7%9A%84%E8%A1%A8%E7%8E%B0\"><span class=\"toc-text\">HTTP2.0 - 为了更优异的表现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BF%E6%8F%92%E4%B8%80%E4%B8%8BHTTPS\"><span class=\"toc-text\">穿插一下HTTPS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP3-0-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E5%BF%AB%E7%9A%84%E9%80%9F%E5%BA%A6\"><span class=\"toc-text\">HTTP3.0 - 为什么更快的速度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Quick%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">Quick是什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">数据包格式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">建立连接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B00RTT%E6%8F%A1%E6%89%8B%EF%BC%9F\"><span class=\"toc-text\">如何做到0RTT握手？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">可靠传输</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">流量控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">拥塞控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%85%A2%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">1.慢启动</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D\"><span class=\"toc-text\">2.拥塞避免</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F\"><span class=\"toc-text\">3.拥塞发生</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D\"><span class=\"toc-text\">4.快速恢复</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">5.拥塞控制常见算法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">解决队头阻塞</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB\"><span class=\"toc-text\">连接迁移</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol></li></ol>","author":{"name":"JuneQQQ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/JuneQQQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_46925850","juejin":"https://juejin.cn/user/3927934338357197","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java 集合","uid":"34c2acd56bc16b503002a852a65f4137","slug":"Java集合详解","date":"2022-09-22T01:13:17.000Z","updated":"2022-09-22T01:15:40.085Z","comments":true,"path":"api/articles/Java集合详解.json","keywords":null,"cover":[],"text":"Java 集合Collection 接口 （父接口） Iterator 迭代器所有实现了Iteratable接口的类都可以通过iterator()方法获取迭代器 注意：重新获取iterator即可重置迭代器； 增强 for 循环 可以对 数组 和 集合 使用； 底层使用的仍然是 ...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"Python","slug":"Python","count":1,"path":"api/tags/Python.json"}],"author":{"name":"JuneQQQ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/JuneQQQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_46925850","juejin":"https://juejin.cn/user/3927934338357197","customs":{}}},"feature":true}}