{"title":"JVM内存与垃圾回收","uid":"cfe9c60f951ff43b26c629865afffd67","slug":"JVM内存与垃圾回收","date":"2022-09-28T09:38:16.000Z","updated":"2022-09-30T10:16:33.897Z","comments":true,"path":"api/articles/JVM内存与垃圾回收.json","keywords":null,"cover":[],"content":"<h1 id=\"内存与垃圾回收篇\"><a href=\"#内存与垃圾回收篇\" class=\"headerlink\" title=\"内存与垃圾回收篇\"></a>内存与垃圾回收篇</h1><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/image20220726152759658.png\" alt=\"image-20220726152759658\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jvm-nei-cun-mo-xing.png\" alt=\"JVM内存模型\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/6deaff4c688e4d2f8248e52366568f4a.png\" alt=\"6deaff4c-688e-4d2f-8248-e52366568f4a\"></p>\n<h2 id=\"类加载子系统\"><a href=\"#类加载子系统\" class=\"headerlink\" title=\"类加载子系统\"></a>类加载子系统</h2><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210915-xia-wu52051.png\" alt=\"截屏2021-09-15下午5.20.51\"></p>\n<ul>\n<li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件表示。</li>\n<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</li>\n<li><strong>加载的类信息存放于一块称为<code>方法区</code>的内存空间</strong>。除了类的信息外，<strong>方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</strong></li>\n</ul>\n<h3 id=\"类加载器ClassLoader角色\"><a href=\"#类加载器ClassLoader角色\" class=\"headerlink\" title=\"类加载器ClassLoader角色\"></a>类加载器ClassLoader角色</h3><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210915-xia-wu53229.png\" alt=\"截屏2021-09-15下午5.32.29\"></p>\n<ol>\n<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模块，而最终这个模板在执行时是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>\n<li>class file 加载到JVM中，被称为DNA元数据模板，放在方法区</li>\n<li>在 .class 文件 -&gt; JVM -&gt; 最终成为元数据模板，此过程就要一个运输工具（类装载器 ClassLoader），扮演一个快递员的角色</li>\n</ol>\n<h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210915-xia-wu53729.png\" alt=\"截屏2021-09-15下午5.37.29\"></p>\n<h4 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h4><ol>\n<li>通过一个类的全限定类名定义此类的二进制字节流</li>\n<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>\n<li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>补充：加载 .class 文件的方式</p>\n<ul>\n<li>从本地系统中直接加载</li>\n<li>通过网络获取，典型场景：Web Applet</li>\n<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>\n<li>运行时计算生成，使用最多的是：动态代理技术</li>\n<li>由其他文件生产，典型场景：JSP应用</li>\n<li>从专有数据库中提取 .class 文件，比较少见</li>\n<li>从加密文件中获取，典型的防class文件被反编译的保护措施</li>\n</ul>\n<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210915-xia-wu101343.png\" alt=\"截屏2021-09-15下午10.13.43\"></p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><ul>\n<li><strong>初始化阶段就是执行类构造器方法<clinit>( )的过程。</strong></li>\n<li>此方法不需要定义，是javac编译器自动收集类中的所有<strong>类变量的赋值动作和静态代码块中的语句</strong>合并而来</li>\n<li>构造器方法中的指令语句在原文件中出现的顺序执行</li>\n<li><strong><clinit>( )不同于类的构造器</strong>。（关联：构造器是虚拟机视角下的<init>( ) ）</li>\n<li>若该类具有父类，JVM会保证子类的<clinit>( ) 执行前，父类的<clinit>( )已经执行完毕。</li>\n<li>虚拟机必须保证一个类的<clinit>( ) 方法在多线程下被同步加锁</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test1</span> <span class=\"token punctuation\">&#123;</span>\n  \t<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> num0 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 实例变量</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> num1 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 静态变量</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n        num1 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        num2 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//        System.out.println(num2); 非法的前项引用</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// num2 -> (链接-prepare)0 -> (初始化) 10(从上到下执行) -> 20(从上到下执行)</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Test1</span><span class=\"token punctuation\">.</span>num1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Test1</span><span class=\"token punctuation\">.</span>num2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"类加载器分类\"><a href=\"#类加载器分类\" class=\"headerlink\" title=\"类加载器分类\"></a>类加载器分类</h3><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210916-xia-wu44453.png\" alt=\"截屏2021-09-16下午4.44.53\"></p>\n<ul>\n<li>JVM支持两种类型的类加载器，分别为<strong>引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</strong></li>\n<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong>。</li>\n<li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下图所示：</li>\n</ul>\n<h4 id=\"虚拟机自带的加载器\"><a href=\"#虚拟机自带的加载器\" class=\"headerlink\" title=\"虚拟机自带的加载器\"></a>虚拟机自带的加载器</h4><ul>\n<li><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>\n<ul>\n<li>这个类加载器<strong>使用C&#x2F;C++语言实现</strong>，嵌套在JVM内部</li>\n<li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar 或 sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>\n<li>并不需要继承自java.lang.ClassLoader，没有父加载器</li>\n<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>\n<li>出去安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun开头的类</li>\n</ul>\n</li>\n<li><p><strong>扩展类加载器（Extension ClassLoader）</strong></p>\n<ul>\n<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为引导类加载器</li>\n<li>从java.ext.dirs系统属性指定的目录中加载类库，或从JDK的安装目录jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。<strong>如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</strong></li>\n</ul>\n</li>\n<li><p><strong>应用程序类加载器（系统类加载器 ，AppClassLoader）</strong></p>\n<ul>\n<li>Java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>\n<li>派生于ClassLoader类</li>\n<li>父类加载器为扩展类加载器</li>\n<li><strong>该类加载器是程序中默认的了加载器</strong>，一般来说，Java应用的类都是由它来完成加载</li>\n<li>通过ClassLoader#getSystemClassLoader( )方法可以获取到该类加载器</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"用户自定义加载器\"><a href=\"#用户自定义加载器\" class=\"headerlink\" title=\"用户自定义加载器\"></a>用户自定义加载器</h4><ul>\n<li>在Java的日常应用程序开发中，类的加载几乎是有上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来制定类的加载方式</li>\n<li><strong>为什么要自定义类加载器？</strong><ul>\n<li>隔离加载类</li>\n<li>修改类加载方式</li>\n<li>扩展加载源</li>\n<li>防止源码泄露</li>\n</ul>\n</li>\n<li>如何自定义加载器？<ul>\n<li>继承 java.lang.ClassLoader 类</li>\n<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadCloass( )方法，从而实现自定义的类加载，但JDK1.2之后已不建议重写该方法，而是建议把自定义的类加载逻辑写在findClass( )方法中</li>\n<li>在编写自定义类加载器时，如果没有太过于复杂的需求，<strong>可以直接继承URLClassLoader类</strong>，这样就可以避免自己去编写 findClass( )方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"关于ClassLoader\"><a href=\"#关于ClassLoader\" class=\"headerlink\" title=\"关于ClassLoader\"></a>关于ClassLoader</h4><p>ClassLoader是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名称</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">getParent( )</td>\n<td align=\"center\">返回该类加载器的超类加载器</td>\n</tr>\n<tr>\n<td align=\"center\">loadClass(String name)</td>\n<td align=\"center\">加载名为 name 的类，返回结果为 java.lang.Class 类的实例</td>\n</tr>\n<tr>\n<td align=\"center\">findClass(String name)</td>\n<td align=\"center\">查找名为 name 的类，返回结果为 java.lang.Class 类的实例</td>\n</tr>\n<tr>\n<td align=\"center\">findLoadedClass(String name)</td>\n<td align=\"center\">查找名为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例</td>\n</tr>\n<tr>\n<td align=\"center\">defineCLass(String name, byte[] b, int off, int len)</td>\n<td align=\"center\">把字节数组b中的内容转换为一个Java类，返回结果为 java.lang.Class类的实例</td>\n</tr>\n<tr>\n<td align=\"center\">resolveClass(Class&lt;?&gt; c)</td>\n<td align=\"center\">连接指定的一个Java类</td>\n</tr>\n</tbody></table>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>获取ClassLoader的三种方式</p></blockquote>\n<ul>\n<li>class.getClassLoader( )  - 获取当前类的</li>\n<li>Thread.currentThread( ).getContextClassLoader( ) - 获取当前线程上下文的</li>\n<li>ClassLoader.getSystemClassLoader( )  - 获取当前系统的</li>\n<li>DriverManager.getCallerClassLoader( ) - 获取调用者的</li>\n</ul>\n<h3 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h3><p><a href=\"http://www.javashuo.com/article/p-cfrecdij-dx.html\">http://www.javashuo.com/article/p-cfrecdij-dx.html</a></p>\n<p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派机制</strong>，<strong>即把请求交由父类处理</strong>，它是一种任务委派模式。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/watermarktypezmfuz3pozw5nagvpdgkshadow10textahr0ch.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//              -----??-----</span>\n<span class=\"token keyword\">protected</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> resolve<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ClassNotFoundException</span>\n<span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 首先，检查是否已经被类加载器加载过</span>\n        <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c <span class=\"token operator\">=</span> <span class=\"token function\">findLoadedClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">// 存在父加载器，递归的交由父加载器</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    c <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span><span class=\"token function\">loadClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token comment\">// 直到最上面的Bootstrap类加载器</span>\n                    c <span class=\"token operator\">=</span> <span class=\"token function\">findBootstrapClassOrNull</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassNotFoundException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">// ClassNotFoundException thrown if class not found</span>\n                <span class=\"token comment\">// from the non-null parent class loader</span>\n            <span class=\"token punctuation\">&#125;</span>\n \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">// If still not found, then invoke findClass in order</span>\n                <span class=\"token comment\">// to find the class.</span>\n                c <span class=\"token operator\">=</span> <span class=\"token function\">findClass</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/watermarktypezmfuz3pozw5nagvpdgkshadow10textahr0ch.png\" alt=\"img\"></p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>避免类的重复加载</li>\n<li>保护程序安全，防止核心API被随意篡改</li>\n</ul>\n<h4 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h4><p>Java安全模型的核心就是Java沙箱。沙箱机制就是<strong>将Java代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地资源的访问</strong>，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏</p>\n<p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载JDK自带的文件（rt.jar包中的java.lang.String ），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对Java核心源代码的保护，这就是沙箱安全机制</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>在JVM中表示两个class对象是否为同一个类存在两个必要条件：<ul>\n<li>类的<strong>完整类名</strong>必须一致，包括包名</li>\n<li>加载这个类的<strong>ClassLoader</strong>必须相同</li>\n</ul>\n</li>\n<li>换句话话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li>\n</ul>\n<h4 id=\"对类加载器的引用\"><a href=\"#对类加载器的引用\" class=\"headerlink\" title=\"对类加载器的引用\"></a>对类加载器的引用</h4><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由后者加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>\n<h4 id=\"类的主动使用和被动使用\"><a href=\"#类的主动使用和被动使用\" class=\"headerlink\" title=\"类的主动使用和被动使用\"></a>类的主动使用和被动使用</h4><p>Java程序对类的使用方式分为：主动使用和被动使用</p>\n<ul>\n<li>主动使用，又分为七种情况：<ul>\n<li>创建类的实例</li>\n<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>\n<li>调用类的静态方法</li>\n<li>反射（比如：Class.forName(“com.example.Test”) ）</li>\n<li>初始化一个类的子类</li>\n<li>Java虚拟机启动时被标明为启动类的类</li>\n<li>JDK 7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li>\n</ul>\n</li>\n<li>除了以上七种情况，其他使用Java类的方式都被看做<strong>类的被动使用，都不会导致类的初始化</strong></li>\n</ul>\n<h2 id=\"运行时数据区\"><a href=\"#运行时数据区\" class=\"headerlink\" title=\"运行时数据区\"></a>运行时数据区</h2><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210916-xia-wu90751.png\" alt=\"截屏2021-09-16下午9.07.51\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210916-xia-wu90926.png\" alt=\"截屏2021-09-16下午9.09.26\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>线程介绍</p></blockquote>\n<ul>\n<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li>\n<li>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。<ul>\n<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>\n</ul>\n</li>\n<li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，他就会调用Java线程中的 run( ) 方法</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JVM系统线程</p></blockquote>\n<ul>\n<li>如果使用jconsole或者任何一个调试工具，都能看到后台有许多线程在运行。这些后台线程不包括调用public static void main(String[ ] ) 的main线程以及所有这个main线程自己创建的线程</li>\n<li>这些主要的后台系统线程在HotSpot JVM里主要是以以下几个：<ul>\n<li><strong>虚拟机线程</strong>：该线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li>\n<li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>\n<li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>\n<li><strong>编译线程</strong>：这种线程在运行时会将字节码编译到本地</li>\n<li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过适当的方法进行处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p>\n<p>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>PC寄存器用来<strong>存储指向下一条指令的地址</strong>，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-shang-wu95517.png\" alt=\"截屏2021-09-17上午9.55.17\"></p>\n<ul>\n<li>它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域。</li>\n<li>在JVM规范中，每个线程都有它自己的程序计数器，是<strong>线程私有</strong>的，生命周期与线程的生命周期保持一致。</li>\n<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。<strong>程序计数器会存储当前线程正在执行的Java方法的JVM指令地址</strong>；或者，如果是在执行native方法，则是未指定值（undefined）。</li>\n<li><strong>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></li>\n<li><strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</strong>。</li>\n<li>它是唯一一个存在Java虚拟机规范中没有规定任何OutOfMemoryErroy情况的区域</li>\n</ul>\n<h4 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-shang-wu101747.png\" alt=\"截屏2021-09-17上午10.17.47\"></p>\n<h4 id=\"两个常见问题\"><a href=\"#两个常见问题\" class=\"headerlink\" title=\"两个常见问题\"></a>两个常见问题</h4><p><strong>① 使用PC寄存器存储字节码指令地址有什么用？</strong><br><strong>为什么使用PC寄存器记录当前线程的执行地址？</strong></p>\n<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>\n<p><strong>② PC寄存器为什么会被设为线程私有？</strong></p>\n<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中的某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或回复，如何保证分毫无差呢？<strong>为了能够准确记录各个线程正在执行的当前字节码指令地址（最好的办法就是每人一份）</strong>，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立运算，从而不会出现相互干扰的情况。</p>\n<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，所以每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br>优点是跨平台、指令集小、编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令。</p>\n<p><strong>栈是运行时单位，而堆是存储的单位。</strong></p>\n<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程创建时都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应一次次的Java方法调用。Java虚拟机栈是线程私有的，生命周期和线程一致。其主要作用是主管Java程序的运行，它保存方法的局部变量（8种数据基本类型和对象的引用地址）、部分结果，参与方法的调用和返回。</p>\n<h4 id=\"栈的优点\"><a href=\"#栈的优点\" class=\"headerlink\" title=\"栈的优点\"></a>栈的优点</h4><ul>\n<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>\n<li>JVM直接对Java栈的操作只有两个：<ul>\n<li>每个方法执行，伴随着进栈（入栈、压栈）</li>\n<li>执行结束后的出栈工作</li>\n</ul>\n</li>\n<li>对于栈来说不存在垃圾回收问题</li>\n</ul>\n<h4 id=\"面试题：开发中遇到的异常有哪些？\"><a href=\"#面试题：开发中遇到的异常有哪些？\" class=\"headerlink\" title=\"面试题：开发中遇到的异常有哪些？\"></a>面试题：开发中遇到的异常有哪些？</h4><ul>\n<li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul>\n<li>如果采用<strong>固定大小</strong>的，那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许得到最大容量，那么虚拟机将抛出一个 <strong>StackOveflowError</strong> 异常</li>\n<li>如果采用<strong>动态扩展</strong>，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将抛出一个 <strong>OutOfMemoryError</strong> 异常</li>\n<li>-Xss256M 可以设置每个虚拟机栈大小</li>\n<li>默认虚拟机栈大小<ul>\n<li><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/image20220201104713266.png\" alt=\"image-20220201104713266\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"栈中存储什么？\"><a href=\"#栈中存储什么？\" class=\"headerlink\" title=\"栈中存储什么？\"></a>栈中存储什么？</h4><ul>\n<li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li>\n<li>在这个线程上正在执行的每个方法都各自对应一个栈帧</li>\n<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>\n</ul>\n<h4 id=\"栈运行原理\"><a href=\"#栈运行原理\" class=\"headerlink\" title=\"栈运行原理\"></a>栈运行原理</h4><ul>\n<li>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈</li>\n<li>在一条活动线程上，一个时间点上，只会有一个活动的栈帧。<strong>即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的</strong>，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li>\n<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li>\n<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>\n<li>不同线程中所包含的栈帧是不允许相互引用的，即不可能存在一个栈帧之中引用另外一个线程的栈帧</li>\n<li>如果当前方法调用了其他方法，方法返回时，当前栈帧会传回次防范的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为栈顶栈帧</li>\n<li>Java方法有两种返回函数的方式，<strong>一种是正常的返回，使用return；另一个是抛出异常。不管是用哪种，都会导致栈帧被弹出。</strong></li>\n</ul>\n<h4 id=\"栈帧的内部结构\"><a href=\"#栈帧的内部结构\" class=\"headerlink\" title=\"栈帧的内部结构\"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p>\n<ul>\n<li><strong>局部变量表（Local Variables）</strong></li>\n<li><strong>操作数栈（Operand Stack）或称为表达式栈</strong></li>\n<li>动态链接（Dynamic Linking）或指向运行时常量池的方法引用</li>\n<li>方法返回地址（Return Address）或方法正常退出或者异常退出的定义</li>\n<li>一些附加信息</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu32142.png\" alt=\"截屏2021-09-17下午3.21.42\"></p>\n<h5 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h5><ul>\n<li>局部变量表也被称为局部变量数组或本地变量表</li>\n<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li>\n<li>由于局部变量是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>\n<li><strong>局部变量表所需的容量大小是在编译期确定下来的，</strong>并保存在方法的Code属性的maximum locall variables数据项中。在方法运行期间是不会改变局部变量表的</li>\n</ul>\n<h6 id=\"关于Slot（槽）的理解\"><a href=\"#关于Slot（槽）的理解\" class=\"headerlink\" title=\"关于Slot（槽）的理解\"></a>关于Slot（槽）的理解</h6><ul>\n<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</li>\n<li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong></li>\n<li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量</li>\n<li>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong><ul>\n<li>byte、short、char 在存储前被转换为int，boolean 也被转换为int，0表示false，非0表示true</li>\n<li>long 和 double 则占两个slot</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu81848.png\" alt=\"截屏2021-09-17下午8.18.48\"></p>\n<h6 id=\"Slot的重复利用\"><a href=\"#Slot的重复利用\" class=\"headerlink\" title=\"Slot的重复利用\"></a>Slot的重复利用</h6><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu82623.png\" alt=\"截屏2021-09-17下午8.26.23\"></p>\n<h6 id=\"举例：静态变量与局部变量的对比\"><a href=\"#举例：静态变量与局部变量的对比\" class=\"headerlink\" title=\"举例：静态变量与局部变量的对比\"></a>举例：静态变量与局部变量的对比</h6><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>静态变量有两次赋初值机会，局部变量没有</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu82723.png\" alt=\"截屏2021-09-17下午8.27.23\"></p>\n<ul>\n<li><strong>成员变量</strong>：在使用前（实例后），都经过默认初始化赋值<ul>\n<li><strong>类变量</strong>（static）：linking(prepare)-&gt;initialization</li>\n<li><strong>实例变量</strong>（no static）：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>\n</ul>\n</li>\n<li><strong>局部变量</strong> ：在使用前，必须显式赋值</li>\n</ul>\n<h6 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h6><ul>\n<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>\n<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会回收</strong></li>\n</ul>\n<h5 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h5><ul>\n<li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个<strong>后进先出</strong>（Last-In-First-Out）的操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li>\n<li><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）&#x2F; 出栈（pop）</strong><ul>\n<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li>\n<li>比如：执行复制、交换、求和等操作</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu91237.png\" alt=\"截屏2021-09-17下午9.12.37\"></p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu91450.png\" alt=\"截屏2021-09-17下午9.14.50\"  />\n\n<h6 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h6><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu101548.png\" alt=\"截屏2021-09-17下午10.15.48\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu100750.png\" alt=\"截屏2021-09-17下午10.07.50\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu100820.png\" alt=\"截屏2021-09-17下午10.08.20\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu100901.png\" alt=\"截屏2021-09-17下午10.09.01\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu101002.png\" alt=\"截屏2021-09-17下午10.10.02\"></p>\n<h6 id=\"栈顶缓存技术\"><a href=\"#栈顶缓存技术\" class=\"headerlink\" title=\"栈顶缓存技术\"></a>栈顶缓存技术</h6><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210917-xia-wu102751.png\" alt=\"截屏2021-09-17下午10.27.51\"></p>\n<h5 id=\"动态链接（指向运行时常量池的方法引用）\"><a href=\"#动态链接（指向运行时常量池的方法引用）\" class=\"headerlink\" title=\"动态链接（指向运行时常量池的方法引用）\"></a>动态链接（指向运行时常量池的方法引用）</h5><ul>\n<li>每一个栈帧内部都包含一个指向<strong>运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的是为了支持当前方法的代码能够实现<strong>动态链接</strong>。比如 invokedynamic 指令</li>\n<li>在Java源文件被编译到字节码文件时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中的指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></li>\n<li>为什么要用常量池？<ul>\n<li>为了提供一些符号和常量，便于指令的识别</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h6><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>\n<ul>\n<li><strong>静态链接</strong></li>\n</ul>\n<p>当一个字节码文件被装载进JVM内部时，如果<strong>被调用的目标方法在编译期可知，且运行期保持不变。</strong>这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>\n<ul>\n<li><strong>动态链接</strong></li>\n</ul>\n<p><strong>如果被调用的方法在编译期无法被确定下来</strong>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此称之为动态链接。</p>\n<hr>\n<p>对应的方法绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p>\n<ul>\n<li><strong>早期绑定</strong></li>\n</ul>\n<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</p>\n<ul>\n<li><strong>晚期绑定</strong></li>\n</ul>\n<p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，称之为晚期绑定。 </p>\n<h6 id=\"方法的调用：虚方法与非虚方法\"><a href=\"#方法的调用：虚方法与非虚方法\" class=\"headerlink\" title=\"方法的调用：虚方法与非虚方法\"></a>方法的调用：虚方法与非虚方法</h6><ul>\n<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为 <strong>非虚方法</strong></li>\n<li><strong>静态方法、私有方法、final方法、实例构造器、父类方法</strong>都是非虚方法。</li>\n<li>其他方法称为虚方法。 </li>\n<li>虚拟机中提供了以下几条方法调用指令：<ul>\n<li>普通调用指令：<ol>\n<li>invokestatic：调用静态方法，解析阶段唯一确定</li>\n<li>invokespecial：调用<init>方法、私有及父类方法，解析阶段唯一确定</li>\n<li>invokevirtual：调用所有虚方法，<strong>不一定真的是是虚方法</strong></li>\n<li>invokeinterface：调用接口方法，虚方法</li>\n</ol>\n</li>\n<li>动态调用指令：<ul>\n<li>invokeddynamic：动态解析出需要调用的方法，然后执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。<strong>其中 invokestatic 和          invokespecial 指令调用的方法称为非虚方法，其余的称为虚方法（final修饰除外）。</strong></p>\n<h6 id=\"方法调用：关于invokedynamic指令\"><a href=\"#方法调用：关于invokedynamic指令\" class=\"headerlink\" title=\"方法调用：关于invokedynamic指令\"></a>方法调用：关于invokedynamic指令</h6><ul>\n<li>JVM字节码指令集一直比较稳定，知道Java7中才增加了一个invokedynamic指令，这是为了Java实现【动态类型语言】支持而做的一种改进。</li>\n<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种字节码工具来产生invokedynamic指令。<strong>知道Java8中的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</strong></li>\n<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来说比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言编译器。</li>\n</ul>\n<h6 id=\"方法调用：方法重写的本质\"><a href=\"#方法调用：方法重写的本质\" class=\"headerlink\" title=\"方法调用：方法重写的本质\"></a>方法调用：方法重写的本质</h6><p>Java 语言中方法重写的本质：</p>\n<ol>\n<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>\n<li>如果在类型 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li>\n<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。</li>\n<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>\n</ol>\n<p><strong>IllegalAccessError介绍</strong></p>\n<p>程序视图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。如果这个错误发生在运行时，就说明一个类发生了不兼容的改变。</p>\n<h6 id=\"方法调用：虚方法表\"><a href=\"#方法调用：虚方法表\" class=\"headerlink\" title=\"方法调用：虚方法表\"></a>方法调用：虚方法表</h6><ul>\n<li>在面向对象编程中，会很频繁的使用到动态分配，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<strong>为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</strong></li>\n<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li>\n<li>那么虚方法表什么时候创建？<ul>\n<li>虚方法表会在<strong>类加载的链接-解析阶段被创建并开始初始化</strong>，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h5><ul>\n<li><strong>存放调用该方法的PC寄存器的值。</strong></li>\n<li>一个方法的结束，有两种方式：<ul>\n<li>正常结束</li>\n<li>异常退出</li>\n</ul>\n</li>\n<li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。</li>\n<li>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></li>\n<li>在字节码指令中，返回指令包括 ireturn（当前返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 <strong>void 的方法、实例初始化方法、类和接口的初始化方法</strong>使用</li>\n</ul>\n<h5 id=\"一些附加信息\"><a href=\"#一些附加信息\" class=\"headerlink\" title=\"一些附加信息\"></a>一些附加信息</h5><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>\n<h4 id=\"虚拟机栈的相关面试题\"><a href=\"#虚拟机栈的相关面试题\" class=\"headerlink\" title=\"虚拟机栈的相关面试题\"></a>虚拟机栈的相关面试题</h4><ol>\n<li><strong>举例栈溢出的情况（StackOverflowError）</strong><ul>\n<li><a href=\"https://blog.csdn.net/weixin_40667145/article/details/78556182\">https://blog.csdn.net/weixin_40667145/article/details/78556182</a></li>\n<li>通过-Xss设置每个线程的栈的总大小；OOM（内存溢出）不同于栈溢出</li>\n</ul>\n</li>\n<li><strong>调整栈大小，就能保证不出现溢出吗？</strong><ul>\n<li>不能</li>\n</ul>\n</li>\n<li><strong>分配的栈内存越大越好吗？</strong><ul>\n<li>栈容量变大，总内存一定，栈的数目就会减少，或者说能开辟的线程变少，所以并不是越大越好</li>\n</ul>\n</li>\n<li><strong>垃圾回收是否会涉及到虚拟机栈？</strong><ul>\n<li><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210918-xia-wu110032.png\" alt=\"截屏2021-09-18下午11.00.32\"></li>\n</ul>\n</li>\n<li><strong>方法定义的局部变量是否线程安全？</strong><ul>\n<li>何为线程安全？<ul>\n<li>如果只有一个线程可以操作此数据，则必是线程安全的。</li>\n<li>如果有多个线程操作此数据，则此数据是共享数据，如果不考虑同步机制的话，会存在线程安全问题。</li>\n</ul>\n</li>\n<li>内部定义内部消亡–安全的；</li>\n<li>以参数传入–不安全的；</li>\n<li>以返回值返回–不安全的；</li>\n</ul>\n</li>\n<li><strong>命令确定异常线程？</strong><ul>\n<li><code>jstack pid</code></li>\n<li><code>top -H -p &lt;pid&gt;</code></li>\n<li><code>jprofiler</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210919-xia-wu51644.png\" alt=\"截屏2021-09-19下午5.16.44\"></p>\n<ul>\n<li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</strong></li>\n<li>本地方法栈，也是线程私有的。</li>\n<li>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）<ul>\n<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。</li>\n<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么虚拟机将会抛出一个 OutOfMemoryError 异常。</li>\n</ul>\n</li>\n<li>本地方法是使用C语言实现的。</li>\n<li>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</li>\n<li><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机用拥有同样的权限。</strong><ul>\n<li>本地方法可以<strong>通过本地方法接口来访问虚拟机内部的运行时数据区</strong></li>\n<li>它甚至可以直接使用本地处理器中的寄存器。</li>\n<li>直接从本地内存的堆中分配任意数量的内存。</li>\n</ul>\n</li>\n<li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈使用的语言、具体实现方式、数据结构等。如果JVM产品不打算支持 native 方法，也可以无需事先本地方法栈。</li>\n<li><strong>在 HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一。</strong></li>\n</ul>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><h4 id=\"堆的核心概述\"><a href=\"#堆的核心概述\" class=\"headerlink\" title=\"堆的核心概述\"></a>堆的核心概述</h4><ul>\n<li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>\n</li>\n<li><p>Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大的一块内存空间。</p>\n<ul>\n<li><p><strong>堆内存的大小是可以调节的</strong></p>\n</li>\n<li><p>&#96;&#96;&#96;ini<br>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k<br>-Xmx3550m：设置JVM最大可用内存为3550M。<br>-Xms3550m：设置JVM初始内存为3550m<br>-Xmn2g：设置年轻代大小为2G。<br>-Xss128k：设置每个线程的栈大小。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n- 《Java虚拟机规范》规定：堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。\n\n- 所有的线程共享Java堆，在这里还可以划分**线程私有的缓冲区**（Thread Local Allocation Buffer，TLAB）。\n\n- 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应该在运行时分配在堆上。\n\n  - “几乎”所有的对象实例都是在这里分配内存。--从实际使用角度来看\n\n- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。\n\n- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除。\n\n- 堆，是GC（Garbage Collection）执行垃圾回收的重点区域。\n\n\n\n#### 堆的核心概述：内存细分\n\n![584866-20170426175411428-34722603](https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;5848662017042617541142834722603.png)\n\n\n\n#### 堆空间大小的设置\n\n- Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项 &#96;-Xmx&#96;和&#96;-Xms&#96;来进行设置\n  - &#96;-Xms&#96;表示堆区的起始内存，等价于&#96;-XX:InitialHeapSize&#96;\n    - 堆空间（年轻代 + 老年代）\n    - -X是JVM的运行参数\n    - ms 是 Memory start\n  - &#96;-Xmx&#96;表示堆区的最大内存，等价于&#96;-XX:MaxHeapSize&#96;\n    - 查看参数的设置：\n      - 方式一：&#96;jinfo -flags &lt;pid&gt;&#96;\n      - 方式二：  &#96;-XX:+PrintFlagsFinal&#96;\n- 一旦堆区中的内存大小超过&#96;-Xmx&#96;所指定的最大内存时，将会抛出OutOfMemoryError异常。\n- 通常会将&#96;-Xms&#96;和&#96;-Xmx&#96;两个参数配置相同的值，**其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分配计算堆区的大小，从而提高性能。**\n- 初始内存大小：物理电脑内存大小 &#x2F; 64 （默认情况下）\n  最大内存大小：物理电脑内存大小 &#x2F; 4\n\n\n\n#### OutOfMemory 举例\n\n![截屏2021-09-20上午11.15.02](https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;jie-ping20210920-shang-wu111502.png)\n\n \n\n#### 新生代与老年代\n\n- 存储在JVM中的Java对象可以被划分为两类：\n  - 一类是生命周期较短的瞬间对象，这类对象的创建和消亡都非常迅速。\n  - 另外一类对象生命周期较长，在某些极端情况下还能够与JVM的生命周期保持一致。\n- Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）\n- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做 from区 、to区）\n\n&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;jie-ping20210920-shang-wu112531.png&quot; alt&#x3D;&quot;截屏2021-09-20上午11.25.31&quot; style&#x3D;&quot;zoom:67%;&quot; &#x2F;&gt;\n\n&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;jie-ping20210920-shang-wu112919.png&quot; alt&#x3D;&quot;截屏2021-09-20上午11.29.19&quot; style&#x3D;&quot;zoom:67%;&quot; &#x2F;&gt;\n\n- 查看以上设置： jinfo -flag NewRatio 进程id（jps  得到）\n\n---\n\n- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是**8:1:1**\n  - &#96;-XX:-UseAdaptiveSizePolicy&#96;：关闭自适应的内存分配策略（实测没用）\n  - 分配空间过小仍然不会达到设定的比例（200M）\n  - 还是需要下面的命令设置 ↓ 注意上面这条 ↑\n- 当然开发人员可以通过选项 &#96;-XX:SurvivorRatio&#96; 调整这个空间比例。\n  - &#96;-XX:NewRatio&#96;：设置老年代与新生代的比例！\n  - &#96;-XX:SurvivorRatio&#96;：设置新生代中Eden区与Survivor区的比例\n  - &#96;-XX:-UseAdaptiveSizePolicy&#96;：关闭自适应分配策略\n  - &#96;-Xmn&#96;：设置新生代空间的大小（该命令优先级比第一条优先）\n  - &#96;-XX:+PrintGCDetails&#96;：打印GC详细信息\n- **几乎所有**的Java对象都是在Eden区被new出来的。\n- 绝大部分的Java对象的销毁都是在新生代中进行的。\n  - IBM公司专门研究表明：新生代中80%的对象都是“朝生夕死”的\n- 可以使用选项&#96;-Xmn&#96;设置新生代最大内存大小\n  - 这个参数一般使用默认值即可\n\n![d](https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;center.png)\n\n\n\n\n\n#### 对象的一般分配过程\n\n##### 对象分配过程：概述\n\n为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。\n\n1. new的对象先放Eden区。此区大小有限制。\n2. 当Eden区空间填满时，程序又需要创建新的对象，JVM的垃圾回收器将对Eden区进行垃圾回收（Minor GC &#x2F; YGC），将此区域中的不再被其他对象所引用的对象进行销毁，再加载新的对象到此区域。\n3. 然后将Eden区中的剩余对象移动到Survivor0区\n4. 如果再次触发垃圾回收，此时上次幸存下来的放到Survivor0区的，如果没有回收，就会放到Survivor1区。\n5. 如果再次经历垃圾回收，此时会重新放回Survivor0区，接着再去Survivor1区。\n6. 什么时候能去老年代？可以设置次数，默认是15次。\n\n   - **&#96;-XX:MaxTenuringThreshold&#x3D;&lt;N&gt;&#96; 进行设置**\n7. 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。\n8. 若养老区执行了Major GC之后发现仍无法进行对象的保存，就会产生OOM错误。\n&gt; 总结\n\n- **针对幸存者s0,s1区：复制后有交换，谁空谁是to。**\n- **关于垃圾回收：频繁在新生区收集，很少在老年区收集，几乎不在永久区 &#x2F; 元空间收集。**\n\n\n\n##### 对象分配过程：特殊情况\n\n![截屏2021-09-20下午12.49.58](https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;jie-ping20210920-xia-wu124958.png)\n\n#####   对象分配过程：图解\n\n![截屏2021-09-20下午7.16.35](https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;jie-ping20210920-xia-wu71635.png)\n\n\n\n#### 常用调优工具\n\n- Eclipse：Memory Analyzer Tool\n- Jconsole\n- VisualVM\n- Jprofiler\n- Java Flight Recoder\n- GCViewer\n- GC Easy\n\n\n\n#### 初步认识几种GC\n\n&gt; Minor GC、Major GC、Full GC\n\nJVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代；方法区）一起回收，大部分时候回收的都是指新生代。\n\n针对HotSp VM的实现，它里面的GC按照回收区域又分为两大类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）\n\n- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：\n  - 新生代收集（Minjor GC &#x2F; Young GC）：只是新生代的垃圾收集。\n  - 老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集。\n    - 目前，只有CMS GC会有单独收集老年代的行为\n    - **注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。**\n  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。\n    - 目前，只有G1 GC会有这种行为。\n- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾。\n\n\n\n##### 最简单的分代式GC策略的触发条件\n\n- **年轻代（Minor GC）触发机制：**\n\n  - 当年轻代空间不足时，就会触发Minor GC，这里的**年轻代满指的是Eden代满，Survivor满不会引发GC。**（每次Minor GC会清理**年轻代的内存**）\n  -  因为Java对象大多具备较短的生命周期，所以Minor GC非常频繁，一般回收速度也比较快，这一定义既清晰又易于理解。\n  - Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。\n\n- **老年代（Major GC&#x2F;Full GC）触发机制：**\n\n  - 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了\n  - 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对，在Parallel Scavenge 收集器的收集策略里就有直接进行Major GC的策略选择过程）。\n    - 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。\n  - Major GC的速度一般会比Minor GC慢十倍以上，STW时间更长。\n  - 如果Major GC之后，内存仍然不足-&gt;OOM \n\n- **Full GC触发机制（后面细讲）触发机制：**\n\n  - 调用System.gc( )时，系统建议执行Full GC，但是不必然执行\n  - 老年代空间不足\n  - 方法区（区分于 堆）空间不足\n  - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n  - 由Eden区、s0（from区）向s1（to区）复制时，对象大小大于to区可用内存，则把对象转存到老年代，这时老年代的可用内存小于对象大小。\n\n  说明：Full GC是开发或调优中要尽量避免的，这样暂停时间更短。\n\n\n\n#### 堆空间分代思想\n\n&gt; 为什么要把Java堆分代？\n\n- 经研究，70%-90%的对象是临时变量。\n  - 新生代：有Eden、两块大小相同的Survivor（又称from&#x2F;to，s0&#x2F;s1）构成，to总为空。\n  - 老年代：存放新生代中经历多次GC仍然存活的对象。\n- 其实不分代完全可以，分代的唯一理由就是**优化GC性能**。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。\n\n####    内存分配策略（对象提升[Promotion]规则）\n\n如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设置为1。对象在Survivor区中没经过一次MinorGC（未被清理），年龄就加一，当它的年龄增加到一定程度（默认15，每个JVM、GC都有所不同）时，就会被晋升到老年代中，设置阈值 &#96;-XX:MaxTenuringThreshold&#96;。\n\n针对不同年龄段的对象分配原则如下所示：\n\n- 优先分配到Eden\n- 大对象直接分配到老年代\n  - 尽量避免程序中出现过多大对象\n- 长期存活的对象分配到老年代\n- 动态对象年龄判断\n  - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold要求的年龄。\n\n#### 为对象分配分配内存：TLAB   \n\n&gt; 什么是TLAB？\n\n[TLAB-简书](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;8be816cbb5ed)\n\n- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为**每个线程都分配了一个私有缓冲区域**，它包含在Eden空间内。\n- 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。\n\n&gt; 为什么要有TLAB（Thread Local Allocation Buffer）？\n\n- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据\n- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。\n- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。\n- 多线程同时分配内存时，使用TLAB可以避免这一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为 **快速分配策略**。\n\n&gt; TLAB详细说明\n\n- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，**但JVM确实是将TLAB作为内存分配的首选。**\n- 可以通过 &#96;-XX:UseTLAB&#96;设置是否开启TLAB空间。\n- 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，可以设置&#96;-XX:TLABWasteTargetPercent&#96;设置TLAB空间所占用的Eden空间百分比大小。\n- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用**加锁机制**确保数据操作的原子性，从而直接在Eden空间中分配内存。\n\n![截屏2021-09-20下午9.46.38](https:&#x2F;&#x2F;markdown-pic-june.oss-cn-beijing.aliyuncs.com&#x2F;2022&#x2F;09&#x2F;30&#x2F;jie-ping20210920-xia-wu94638.png)\n\n \n\n#### 小结堆空间常用参数\n\n&#96;&#96;&#96;shell\n-XX:+PrintFlagsInitial  #查看所有的参数的默认初始值\n-XX:+PrintFlagsFinal    #查看所有的参数的最终值\n\t具体查看某个参数的指令： jps  -查看当前运行中的进程\n\t\t\t\t\t\t\t\tjinfo  -flag SruvivorRatio 进程id\n-Xms\t\t\t\t\t\t#初始堆空间内存（默认 1&#x2F;64物理内存）\n-Xmx\t\t\t\t\t\t#最大堆空间内存（默认 1&#x2F;4物理内存）\n-Xmn \t\t\t\t\t\t#设置新生代大小（初始值及最大值）\n-XX:NewRatio\t\t#配置老年代与新生代在堆结构的占比\n-XX:SurvivorRatio \t#设置新生代中Eden和S0&#x2F;S1的比例。过大会导致Minor GC失去意义，Major GC频繁；过小会导致YGC频繁，STW时间边长。\n-XX:MaxTenuringThreshold:  #设置新生代垃圾的最大年龄\n-XX:+PrintGCDetails\t\t\t\t#输出详细的GC日志\n打印简要信息： -XX:+PrintGC   -verbose:gc\n-XX:HandlePromotionFailure  #是否设置空间分配担保<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-shang-wu104650.png\" alt=\"截屏2021-09-21上午10.46.50\"></p>\n<h4 id=\"堆是对象存储的唯一选择吗？\"><a href=\"#堆是对象存储的唯一选择吗？\" class=\"headerlink\" title=\"堆是对象存储的唯一选择吗？\"></a>堆是对象存储的唯一选择吗？</h4><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分析、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。</p>\n<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的的尝试。但是，有一种特殊情况，那就是如果经过<strong>逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需堆分配内存，也无需垃圾回收了，这也是最常见的对外存储技术。</p>\n<p>此外，前面提到的基于OpenJDK深度定制的TaoBaoJVM，其中创新的GCIH（GC Invisible Heap）技术实现Off-Heap，将生命周期较长的对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>\n<h5 id=\"逃逸分析概述\"><a href=\"#逃逸分析概述\" class=\"headerlink\" title=\"逃逸分析概述\"></a>逃逸分析概述</h5><ul>\n<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li>\n<li>这是一种<strong>可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</strong></li>\n<li>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用适用范围从而决定是否要将这个对象分配到堆上。</li>\n<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>\n<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>\n<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他方法中。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-shang-wu111156.png\" alt=\"截屏2021-09-21上午11.11.56\"> </p>\n<h6 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h6><ul>\n<li>在JDK 6u23之后，HotSpot中默认开启了逃逸分析。</li>\n<li>命令开启：<code>-XX:+DoEscapeAnalysis</code></li>\n<li>查看逃逸分析的筛选结果：<code>-XX:+PrintEscapeAnalysis</code></li>\n</ul>\n<h6 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h6><p>开发中能使用局部变量的，就不要使用在方法外定义。</p>\n<h5 id=\"逃逸分析-代码优化\"><a href=\"#逃逸分析-代码优化\" class=\"headerlink\" title=\"逃逸分析-代码优化\"></a>逃逸分析-代码优化</h5><p>使用逃逸分析，编译器可以对代码做如下优化：</p>\n<ol>\n<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</li>\n<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>\n<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>\n</ol>\n<h6 id=\"代码优化之栈上分配\"><a href=\"#代码优化之栈上分配\" class=\"headerlink\" title=\"代码优化之栈上分配\"></a>代码优化之栈上分配</h6><ul>\n<li>JIT编译器在编译期间根据逃逸分析的结果，发现<strong>如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收；</strong></li>\n<li><strong>常见的栈上分配的场景</strong><ul>\n<li>给成员变量赋值、方法返回值、实例引用传递。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"逃逸分析之同步省略\"><a href=\"#逃逸分析之同步省略\" class=\"headerlink\" title=\"逃逸分析之同步省略\"></a>逃逸分析之同步省略</h6><ul>\n<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>\n<li>在动态编译同步块的时候，<strong>JIT编译器可以借助逃逸分析来判断代码块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</strong>如果没有，那么JIT编译器在编译这个同步代码块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做同步省略，也叫<strong>锁消除</strong>。</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-xia-wu22435.png\" alt=\"截屏2021-09-21下午2.24.35\"></p>\n<h6 id=\"逃逸分析之标量替换\"><a href=\"#逃逸分析之标量替换\" class=\"headerlink\" title=\"逃逸分析之标量替换\"></a>逃逸分析之标量替换</h6><p><strong>标量（Scalar）</strong>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>\n<p>相对的，那些还可以分解的数据叫做<strong>聚合量（Aggregate）</strong>，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>\n<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个包含若干个成员变量来替代，这个过程就是标量替换。</p>\n<p><strong>参数设置</strong>：<code>-XX:+EliminateAllocations</code> 开启标量替换（默认开启），允许将对象打散分配在栈上。  </p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-xia-wu24249.png\" alt=\"截屏2021-09-21下午2.42.49\"></p>\n<h4 id=\"本章小结\"><a href=\"#本章小结\" class=\"headerlink\" title=\"本章小结\"></a>本章小结</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-xia-wu24745.png\" alt=\"截屏2021-09-21下午2.47.45\"></p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><h4 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-xia-wu31425.png\" alt=\"截屏2021-09-21下午3.14.25\"></p>\n<ul>\n<li>方法区和堆一样，是各个线程共享的区域。</li>\n<li>方法区在JVM启动时被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>\n<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>\n<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code></li>\n<li>关闭JVM就会释放这个区域的内存。</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/image20220201115232457.png\" alt=\"image-20220201115232457\"></p>\n<h4 id=\"栈、堆、方法区的交互关系\"><a href=\"#栈、堆、方法区的交互关系\" class=\"headerlink\" title=\"栈、堆、方法区的交互关系\"></a>栈、堆、方法区的交互关系</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-xia-wu30329.png\" alt=\"截屏2021-09-21下午3.03.29\"></p>\n<h4 id=\"HotSpot中方法区的演进\"><a href=\"#HotSpot中方法区的演进\" class=\"headerlink\" title=\"HotSpot中方法区的演进\"></a>HotSpot中方法区的演进</h4><ul>\n<li><strong>在JDK 7 及以前，习惯上把方法区，称为永久代。JDK 8 开始，使用元空间取代了永久代。</strong></li>\n<li>本质上，方法区和永久代并不等价，仅是对HotSpot而言。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRocikt、IBM J9中不存在永久代的概念。<ul>\n<li>现在来看，当年使用永久代，不是好的idea，导致Java程序更容易OOM（超过-XX:MaxPermSize设定值）</li>\n</ul>\n</li>\n<li>而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替。</li>\n<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代最大的区别在于：<strong>元空间不设置在虚拟机设置的内存中，而是使用本地内存。</strong></li>\n<li>永久代、元空间二者并不只是名字变了，内部结构也变了。</li>\n<li>根据《Java虚拟机规范》规定：如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li>\n</ul>\n<h4 id=\"常量池-解释\"><a href=\"#常量池-解释\" class=\"headerlink\" title=\"常量池-解释\"></a>常量池-解释</h4><ul>\n<li><strong>常量池</strong>，即一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</li>\n<li><strong>运行时常量池</strong>，在 class 文件中，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址，这是内存中的常量池形式</li>\n</ul>\n<h4 id=\"设置方法区大小与OOM\"><a href=\"#设置方法区大小与OOM\" class=\"headerlink\" title=\"设置方法区大小与OOM\"></a>设置方法区大小与OOM</h4><ul>\n<li>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</li>\n<li>JDK 7及以前：<ul>\n<li>通过<code>-XX:PermSize</code>设置永久代初始分配空间。默认是20.75M</li>\n<li><code>-XX:MaxPermSize</code>设置永久代最大可用分配空间，32位机器默认64M，64位默认82M。</li>\n<li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code></li>\n</ul>\n</li>\n<li>JDK 8及以后：<ul>\n<li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定，替代上述原有的两个参数。</li>\n<li>默认值依赖于平台。windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code> 的值是-1，即没有限制。</li>\n<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></li>\n<li><code>-XX:MetaspaceSize</code>：设置初始元空间大小。对于一个64位的服务器端JVM来说，其默认的<code>-XX:MetaspaceSize</code>值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则适当降低该值。</li>\n<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将 <code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"如何解决这些OOM？\"><a href=\"#如何解决这些OOM？\" class=\"headerlink\" title=\"如何解决这些OOM？\"></a>如何解决这些OOM？</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-xia-wu92317.png\" alt=\"截屏2021-09-21下午9.23.17\"></p>\n<h4 id=\"方法区的内部结构\"><a href=\"#方法区的内部结构\" class=\"headerlink\" title=\"方法区的内部结构\"></a>方法区的内部结构</h4><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210921-xia-wu92545.png\" alt=\"截屏2021-09-21下午9.25.45\" style=\"zoom:50%;\" />\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>方法区存储什么？</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/image20220330122814459.png\" alt=\"image-20220330122814459\"></p>\n<p>《深入理解Java虚拟机》书中对方法区存储内容描述如下：它用于存储<strong>已被虚拟机加载的类型信息（全类名、父类名、接口列表、修饰符）、常量、静态变量（JDK6及以前）、即时编译器编译后的代码缓存</strong>等。</p>\n<h5 id=\"类型信息\"><a href=\"#类型信息\" class=\"headerlink\" title=\"类型信息\"></a>类型信息</h5><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>\n<ol>\n<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>\n<li>这个类型直接父类的完整有效名（对于interface或是Object，都没有父类）</li>\n<li>这个类型的修饰符（public，abstract，final的某个子集）</li>\n<li>这个类型直接接口的一个有序列表</li>\n</ol>\n<h5 id=\"域（Field）信息\"><a href=\"#域（Field）信息\" class=\"headerlink\" title=\"域（Field）信息\"></a>域（Field）信息</h5><ul>\n<li>JVM必须在方法区中保存类型的所有域相关信息以及域的声明顺序。</li>\n<li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）</li>\n</ul>\n<h5 id=\"方法（Method）信息\"><a href=\"#方法（Method）信息\" class=\"headerlink\" title=\"方法（Method）信息\"></a>方法（Method）信息</h5><p>JVM保存所有方法的以下信息，同域信息包括声明顺序：</p>\n<ul>\n<li>方法名称</li>\n<li>方法返回类型（包括void）</li>\n<li>方法参数的数量和类型（按顺序）</li>\n<li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的一个子集）</li>\n<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>\n<li>异常表（abstract和natvie方法除外）<ul>\n<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> non-final的类变量</p></blockquote>\n<ul>\n<li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。</li>\n<li>类变量被类的所有实例共享，<strong>即使没有类实例也可以访问它。</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 补充说明：全局常量：static fiinal</p></blockquote>\n<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>\n<h5 id=\"运行时常量池-amp-常量池\"><a href=\"#运行时常量池-amp-常量池\" class=\"headerlink\" title=\"运行时常量池 &amp; 常量池\"></a>运行时常量池 &amp; 常量池</h5><ul>\n<li><strong>方法区，内部包含了运行时常量池。</strong></li>\n<li><strong>字节码文件，内部包含了常量池。</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为什么需要常量池？</p></blockquote>\n<p>一个java源文件中的类、接口、编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另外一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p>\n<p>比如：如下的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleClass</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>虽然只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里代码量其实已经很小了，如果代码多，引用到的结构会更多！这里就需要使用常量池。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>常量池中有什么?</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu21419.png\" alt=\"截屏2021-09-22下午2.14.19\"></p>\n<p><strong>小结：</strong></p>\n<p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>运行时常量池</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu21721.png\" alt=\"截屏2021-09-22下午2.17.21\"></p>\n<h4 id=\"方法区使用举例\"><a href=\"#方法区使用举例\" class=\"headerlink\" title=\"方法区使用举例\"></a>方法区使用举例</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu22915.png\" alt=\"截屏2021-09-22下午2.29.15\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu23636.png\" alt=\"截屏2021-09-22下午2.36.36\"></p>\n<p> <img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu23801.png\" alt=\"截屏2021-09-22下午2.38.01\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu23858.png\" alt=\"截屏2021-09-22下午2.38.58\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24036.png\" alt=\"截屏2021-09-22下午2.40.36\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24120.png\" alt=\"截屏2021-09-22下午2.41.20\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24342.png\" alt=\"截屏2021-09-22下午2.43.42\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24415.png\" alt=\"截屏2021-09-22下午2.44.15\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24512.png\" alt=\"截屏2021-09-22下午2.45.12\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24615.png\" alt=\"截屏2021-09-22下午2.46.15\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24644.png\" alt=\"截屏2021-09-22下午2.46.44\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu24741.png\" alt=\"截屏2021-09-22下午2.47.41\"></p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu25227.png\" alt=\"截屏2021-09-22下午2.52.27\"  />\n\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu25244.png\" alt=\"截屏2021-09-22下午2.52.44\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu25312.png\" alt=\"截屏2021-09-22下午2.53.12\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu25329.png\" alt=\"截屏2021-09-22下午2.53.29\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu25329.png\" alt=\"截屏2021-09-22下午2.53.29\"></p>\n<h4 id=\"方法区的演进细节\"><a href=\"#方法区的演进细节\" class=\"headerlink\" title=\"方法区的演进细节\"></a>方法区的演进细节</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu30210.png\" alt=\"截屏2021-09-22下午3.02.10\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu31118.png\" alt=\"截屏2021-09-22下午3.11.18\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu31152.png\" alt=\"截屏2021-09-22下午3.11.52\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu31308.png\" alt=\"截屏2021-09-22下午3.13.08\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>永久代为什么要被元空间替换？</p></blockquote>\n<ul>\n<li>随着Java 8 的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与<strong>堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</strong></li>\n<li>这项改动的原因如下：<ol>\n<li><strong>为永久代设置空间大小是很难确定的。</strong>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</li>\n<li><strong>对永久代进行调优是很困难的。</strong></li>\n</ol>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>StringTable（字符串常量池）为什么要调整？</p></blockquote>\n<p>JDK 7 中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量得字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。 </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>静态变量放在哪？</p></blockquote>\n <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// -XX:+PrintGCDetails</span>\n<span class=\"token comment\">// 实验发现：JDK 6，7，8 new出来的对象始终放在堆中</span>\n  \n<span class=\"token comment\">// 而通过下面的实验，得出的结论是：</span>\n<span class=\"token comment\">// 位置发生变化的是 类本身存储位置</span>\n<span class=\"token comment\">// 6：静态变量存放在方法区（永久代）</span>\n<span class=\"token comment\">// 7&amp;8:</span>\n<span class=\"token comment\">// 局部变量（基本数据类型） 本身存放在栈帧中的局部变量表中</span>\n<span class=\"token comment\">// 成员变量（非static修饰的） 本身随着对象实例放在 堆 中</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu74303.png\" alt=\"截屏2021-09-22下午7.43.03\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu74358.png\" alt=\"截屏2021-09-22下午7.43.58\"></p>\n<h4 id=\"方法区的垃圾回收\"><a href=\"#方法区的垃圾回收\" class=\"headerlink\" title=\"方法区的垃圾回收\"></a>方法区的垃圾回收</h4><h5 id=\"方法区的垃圾收集\"><a href=\"#方法区的垃圾收集\" class=\"headerlink\" title=\"方法区的垃圾收集\"></a>方法区的垃圾收集</h5><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集齐存在（如JDK 11时期的ZGC收集器就不支持类卸载）。</p>\n<p><strong>一般来说这个区域的回收效果比较难以令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。</strong>以前Sun公司的Bug列表中，曾出现过若干个严重的就是由于低版本的HopSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>\n<p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</strong></p>\n<ul>\n<li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”条件就比较苛刻了，有以下三个条件：<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>\n<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则是很难达成的。</li>\n<li>该类对应的java.lang.Class。对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n</li>\n<li>Java虚拟机被允许满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有了引用就必然会被回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载信息和卸载信息</li>\n<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，<strong>通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</strong></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu83457.png\" alt=\"截屏2021-09-22下午8.34.57\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu83706.png\" alt=\"截屏2021-09-22下午8.37.06\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210922-xia-wu84700.png\" alt=\"截屏2021-09-22下午8.47.00\"></p>\n<h3 id=\"执行引擎\"><a href=\"#执行引擎\" class=\"headerlink\" title=\"执行引擎\"></a>执行引擎</h3><h4 id=\"执行引擎概述\"><a href=\"#执行引擎概述\" class=\"headerlink\" title=\"执行引擎概述\"></a>执行引擎概述</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu45319.png\" alt=\"截屏2021-09-23下午4.53.19\"></p>\n<ul>\n<li>执行引擎是Java虚拟机核心的组成部分之一。</li>\n<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地指定指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式。</strong></li>\n<li>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅是一些能被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>\n<li>如果想要一个Java程序跑起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令</strong>才可以。简而言之，JVM中的执行引擎充当了将高级语言翻译为机器语言的功能。</li>\n</ul>\n<h4 id=\"Java代码编译和执行过程\"><a href=\"#Java代码编译和执行过程\" class=\"headerlink\" title=\"Java代码编译和执行过程\"></a>Java代码编译和执行过程</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu51122.png\" alt=\"截屏2021-09-23下午5.11.22\"></p>\n<p>大部分的程序代码转换为物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的各个步骤。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为什么说Java是半编译半解释型语言？</p></blockquote>\n<p>JDK1.0时代，将Java语言定位为“解释执行“还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>\n<h4 id=\"机器码、指令、汇编语言\"><a href=\"#机器码、指令、汇编语言\" class=\"headerlink\" title=\"机器码、指令、汇编语言\"></a>机器码、指令、汇编语言</h4><h5 id=\"机器码\"><a href=\"#机器码\" class=\"headerlink\" title=\"机器码\"></a>机器码</h5><ul>\n<li>采用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它编写程序，这就是机器语言。</li>\n<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>\n<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编写的程序相比，执行速度最快。</li>\n<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>\n</ul>\n<h5 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h5><ul>\n<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li>\n<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文缩写，如mov，inc等），可读性稍好。</li>\n<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li>\n</ul>\n<h5 id=\"指令集\"><a href=\"#指令集\" class=\"headerlink\" title=\"指令集\"></a>指令集</h5><ul>\n<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>\n<li>如常见的<ul>\n<li>x86指令集，对应的是x86架构的平台</li>\n<li>ARM指令集，对应的是ARM架构平台</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"汇编语言\"><a href=\"#汇编语言\" class=\"headerlink\" title=\"汇编语言\"></a>汇编语言</h5><ul>\n<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>\n<li>在汇编语言中，使用助记符（Mnemoics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li>\n<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>\n<li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器码指令，计算机才能识别和执行。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"高级语言\"><a href=\"#高级语言\" class=\"headerlink\" title=\"高级语言\"></a>高级语言</h5><ul>\n<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言，高级语言比计算机语言、汇编语言更接近人类的语言</li>\n<li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</li>\n</ul>\n<h5 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h5><ul>\n<li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更具体，需要直译器转译后才能成为机器码</li>\n<li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li>\n<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul>\n<li>字节码典型应用为Java bytecode</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"解释器\"><a href=\"#解释器\" class=\"headerlink\" title=\"解释器\"></a>解释器</h4><p>Java设计者们的初衷仅仅是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>\n<p>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。</p>\n<ul>\n<li>字节码解释器在执行时通过<strong>纯软件代码模拟字节码的执行</strong>，效率非常低下。</li>\n<li>模板解释器<strong>将每一条字节码和一个函数模板相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很 大程度上提高了解释器的性能。<ul>\n<li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul>\n<li>Interpreter模块：实现了解释器的核心功能</li>\n<li>Code模块：用于管理HotSpot VM在运行时产生的本地机器指令</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>现状</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu83053.png\" alt=\"截屏2021-09-23下午8.30.53\"></p>\n<h4 id=\"JIT编译器\"><a href=\"#JIT编译器\" class=\"headerlink\" title=\"JIT编译器\"></a>JIT编译器</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu83315.png\" alt=\"截屏2021-09-23下午8.33.15\"></p>\n<ul>\n<li>HotSpot VM是市面上高性能虚拟机的代表之作。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li>\n<li>如今，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。</li>\n</ul>\n<h5 id=\"问题来了\"><a href=\"#问题来了\" class=\"headerlink\" title=\"问题来了\"></a>问题来了</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu84804.png\" alt=\"截屏2021-09-23下午8.48.04\"></p>\n<h5 id=\"编译-概念解释\"><a href=\"#编译-概念解释\" class=\"headerlink\" title=\"编译 - 概念解释\"></a>编译 - 概念解释</h5><ul>\n<li>Java语言的“编译期”其实是一段“不确定的”操作过程，因为它可能是指一个<strong>前端编译器</strong>（其实叫“编译期的前端”更贴切）<strong>把 .java 文件转变成 .class 文件的过程；</strong></li>\n<li>也可能是指<strong>虚拟机的后端运行期编译器</strong>（JIT编译器，Just In Time Compiler）<strong>把字节码转变成机器码的过程；</strong></li>\n<li>还可能是指静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把 .java文件编译成本地机器代码的过程。</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu85616.png\" alt=\"截屏2021-09-23下午8.56.16\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu90319.png\" alt=\"截屏2021-09-23下午9.03.19\"></p>\n<h5 id=\"热点代码及探测方式\"><a href=\"#热点代码及探测方式\" class=\"headerlink\" title=\"热点代码及探测方式\"></a>热点代码及探测方式</h5><ul>\n<li><p><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称OSR（On Stack Replacement）编译。</p>\n</li>\n<li><p>一个方法究竟要被调用多少次，或者一个循环体究竟要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译期才会将这些“热点代码”编译为本地机器指令执行，这里主要靠<strong>热点探测功能.</strong></p>\n</li>\n<li><p><strong>目前HotSpot VM 所采用的热点探测方式是基于计数器的热点探测。</strong></p>\n</li>\n<li><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立两个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>\n<ul>\n<li>方法调用计数器用于统计方法的调用次数</li>\n<li>回边计数器则用于统计循环体执行的循环次数</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"方法调用计数器\"><a href=\"#方法调用计数器\" class=\"headerlink\" title=\"方法调用计数器\"></a>方法调用计数器</h6><ul>\n<li>这个计数器就用于方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li>\n<li>这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</li>\n<li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已经被编译过的版本，则将此方法的调用计数器值 +1，然后判断方法调用计数器与回边计数器值的和是否超过方法调用计数器的阈值，如果超过，那么将会向即时编译器提交一个该方法的代码编译请求。</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210924-shang-wu103021.png\" alt=\"截屏2021-09-24上午10.30.21\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>热度衰减</p></blockquote>\n<ul>\n<li>如果不作任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的<strong>时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那么这个方法的调用计数器就会被<strong>减少一半</strong>，这个过程称为方法调用计数器热度的<strong>衰减（Counter Decay）</strong>，而这段时间就称为此方法统计的<strong>半衰周期（Counter Half Life Time）。</strong></li>\n<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>\n<li>另外可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</li>\n</ul>\n<h5 id=\"HotSpot-VM可以设置程序执行方式\"><a href=\"#HotSpot-VM可以设置程序执行方式\" class=\"headerlink\" title=\"HotSpot VM可以设置程序执行方式\"></a>HotSpot VM可以设置程序执行方式</h5><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-Xint</span>      <span class=\"token comment\"># 采用完全解释器模式</span>\n<span class=\"token parameter variable\">-Xcomp</span>     <span class=\"token comment\"># 采用完全JIT编译器模式，如果编译出现问题，解释器介入</span>\n<span class=\"token parameter variable\">-Xmixed</span>    <span class=\"token comment\"># 混合模式</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h5 id=\"HotSpot-VM中JIT分类\"><a href=\"#HotSpot-VM中JIT分类\" class=\"headerlink\" title=\"HotSpot VM中JIT分类\"></a>HotSpot VM中JIT分类</h5><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令指定编译器：</p>\n<ul>\n<li><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul>\n<li><strong>C1编译器会对字节码进行简单和可靠的优化，耗时短</strong>，以达到更快的编译速度。</li>\n</ul>\n</li>\n<li><code>-server</code>：指定Java虚拟机运行在Server模式下，并使用C2编译器。<ul>\n<li><strong>C2进行耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"C1和C2编译器不同的优化策略\"><a href=\"#C1和C2编译器不同的优化策略\" class=\"headerlink\" title=\"C1和C2编译器不同的优化策略\"></a>C1和C2编译器不同的优化策略</h6><ul>\n<li>在不同的编译器上有不同的优化策略，C1编译器上主要由方法内联，去虚拟化、冗余消除。<ul>\n<li>方法内敛：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程。</li>\n<li>去虚拟化：对唯一的实现类进行内联</li>\n<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>\n</ul>\n</li>\n<li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul>\n<li>标量替换：用标量值代替聚合对象的属性值</li>\n<li>栈上分配：对于未逃逸的对象分配对象在栈上而不是堆</li>\n<li>同步消除：清除同步操作，通常指synchronized</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"写在最后1：\"><a href=\"#写在最后1：\" class=\"headerlink\" title=\"写在最后1：\"></a>写在最后1：</h5><ul>\n<li>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器。</li>\n<li>编译效果短短几年时间就追平了C2编译器，未来可期。</li>\n<li>目前，带着“试验状态”标签，需要使用开关参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code>去激活才能使用</li>\n</ul>\n<h5 id=\"写在最后2：关于AOT编译器\"><a href=\"#写在最后2：关于AOT编译器\" class=\"headerlink\" title=\"写在最后2：关于AOT编译器\"></a>写在最后2：关于AOT编译器</h5><ul>\n<li>JDK 9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）</li>\n<li>Java 9 引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</li>\n<li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，<strong>即时编译器指的是在程序运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而<strong>AOT编译器指的则是，在程序运行之前，便将字节码转换为机器码的过程。</strong></li>\n<li>最大好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来的“第一次运行慢”的不良体验。</li>\n<li>缺点：<ul>\n<li>破坏了java“一次编译，到处运行”，必须为每个不同硬件，OS编译对应的发行包。</li>\n<li><strong>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。</strong></li>\n<li>还需要继续优化中，最初只支持Linux x64 java base</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面试提要：String-相关\"><a href=\"#面试提要：String-相关\" class=\"headerlink\" title=\"面试提要：String 相关\"></a>面试提要：String 相关</h3><h4 id=\"String-的基本特性\"><a href=\"#String-的基本特性\" class=\"headerlink\" title=\"String 的基本特性\"></a>String 的基本特性</h4><ul>\n<li>String：字符串，使用一对””引起来表示。<ul>\n<li>String s1 &#x3D; “ads”;   &#x2F;&#x2F;字面量定义方式</li>\n<li>String s2 &#x3D; new String(“hello”);</li>\n</ul>\n</li>\n<li>String 声明为 final，不可被继承</li>\n<li>String 实现了 Serializable 接口：表示字符串是支持序列化的。实现了Comparable接口：表示 String 可以比较大小</li>\n<li><strong>JDK 8 -&gt; JDK 9 : final char[ ] -&gt; final byte[ ]</strong></li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210924-xia-wu125749.png\" alt=\"截屏2021-09-24下午12.57.49\"></p>\n<ul>\n<li><strong>字符串常量池是不会存储相同内容的字符串的。</strong></li>\n<li>String 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，导致链表会很长，而链表长了以后直接会造成的影响就是当调用String.intern时性能大幅度下降。</li>\n<li>使用<code>-XX:StringTableSize</code>可设置StringTable的长度</li>\n<li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求</li>\n<li>在JDK7中，StringTable的长度默认值是60013，长度设置没有要求</li>\n<li>在JDK8开始，设置StringTable长度最小值是1009</li>\n</ul>\n<h4 id=\"String-的内存分配\"><a href=\"#String-的内存分配\" class=\"headerlink\" title=\"String 的内存分配\"></a>String 的内存分配</h4><ul>\n<li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li>\n<li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，<strong>String类型的常量池比较特殊。它的主要使用方法有两种。</strong><ul>\n<li>直接使用双引号声明出来的String对象会直接存储在常量池中。<ul>\n<li>比如：String info &#x3D; “xxx”；</li>\n</ul>\n</li>\n<li>如果不是使用双引号声明的String对象，可以使用String提供的intern( )方法。下面会讲到。</li>\n</ul>\n</li>\n<li>Java8元空间，字符串常量在堆。</li>\n</ul>\n<h4 id=\"字符串拼接操作\"><a href=\"#字符串拼接操作\" class=\"headerlink\" title=\"字符串拼接操作\"></a>字符串拼接操作</h4><ol>\n<li>常量与常量的拼接结果在常量池，原理是编译期优化</li>\n<li>常量池中不会存在相同内容的字符串</li>\n<li>只要其中有一个是变量，结果就在堆中，变量拼接的原理是 StringBuilder</li>\n<li>如果拼接的结果调用 intern( )方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象。 </li>\n<li>使用StringBuilder的append( )方式添加字符串效率要远高于String的+ 字符串拼接方式，前者只创建了一个对象，后者每拼接一次，就要创建一个StringBuilder对象。 <ul>\n<li>如果基本确定要创建的字符串大小，建议使用构造器</li>\n<li>StringBuilder(int capacity)   &#x2F;&#x2F; char[ capacity ]</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210924-xia-wu103219.png\" alt=\"截屏2021-09-24下午10.32.19\"></p>\n<p> <img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210924-xia-wu104208.png\" alt=\"截屏2021-09-24下午10.42.08\"></p>\n<p> <img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210924-xia-wu104455.png\" alt=\"截屏2021-09-24下午10.44.55\"></p>\n<h4 id=\"intern-使用\"><a href=\"#intern-使用\" class=\"headerlink\" title=\"intern( ) 使用\"></a>intern( ) 使用</h4><p><strong>JDK 6 与 7&amp;8对于字符串常量池中不存在的对象的处理不同</strong>：</p>\n<ul>\n<li>JDK6 在字符串常量池中创建新的对象返回这个对象的地址</li>\n<li>JDK7以后只是在字符串常量池中存储调用方法对象的指针，并返回，本质上没有创建新对象</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210924-xia-wu112002.png\" alt=\"截屏2021-09-24下午11.20.02\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>new String(“ab”)会创建几个对象？和new String(“a”) + new String(“b”)、”ab” 有什么区别？</p></blockquote>\n<p>两个，一个对象是：new关键字在堆空间创建的，另一个对象是：字符串常量池中的对象。字节码指令：ldc；</p>\n<p>String s &#x3D; “ab” 这样创建直接在串池中创建了一个对象 “ab” ，s指向这个对象</p>\n<p>new String(“a”) + new String(“b”) 创建了6个对象（注意串池不创建对象”ab”）案例如下</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>new String(“a”) + new String(“b”) + new String(“c”) 创建几个对象？</p></blockquote>\n<p>对象1：new StringBuilder( ) （字符串拼接会首先创建StringBuilder）<br>对象2：new String(“a”)<br>对象3：常量池中的”a”<br>对象4：new String(“b”)<br>对象5：常量池中的”b”<br>对象6：new String(“c”)<br>对象7：常量池中的”c”<br>对象8：new String(“abc”)  （toString不创建”abc”串池对象，其构造方法用的char[]&#x2F;byte[]）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210925-xia-wu124405.png\" alt=\"截屏2021-09-25下午12.44.05\"></p></blockquote>\n<p>JDK 6 : false &#x2F; false<br>JDK 7&amp;8：false &#x2F; true</p>\n<h5 id=\"总结String的intern-的使用\"><a href=\"#总结String的intern-的使用\" class=\"headerlink\" title=\"总结String的intern( ) 的使用\"></a>总结String的intern( ) 的使用</h5><ul>\n<li>在JDK1.6中，将这个字符串对象尝试放入字符串常量池<ul>\n<li>如果其中存在，啥也不做，返回串池中的地址；</li>\n<li>如果不存在，仅在字符串常量池中创建一份，返回串池对象地址。</li>\n</ul>\n</li>\n<li>自JDK1.7起，将这个字符串对象尝试放入字符串常量池<ul>\n<li>如果其中存在，啥也不做，返串池的地址；</li>\n<li>如果不存在，则会把<strong>调用对象的引用地址</strong>复制一份，<strong>放入串池</strong>，并返回该地址，<strong>访问串池对象实际都是访问这个已经创建过的堆空间对象</strong></li>\n</ul>\n</li>\n<li>以上的其中都是指字符串常量池</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210925-xia-wu12136.png\" alt=\"截屏2021-09-25下午1.21.36\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210925-xia-wu12422.png\" alt=\"截屏2021-09-25下午1.24.22\"></p>\n<h5 id=\"Intern-效率测试：空间角度\"><a href=\"#Intern-效率测试：空间角度\" class=\"headerlink\" title=\"Intern( )效率测试：空间角度\"></a>Intern( )效率测试：空间角度</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210925-xia-wu14041.png\" alt=\"截屏2021-09-25下午1.40.41\"></p>\n<p><strong>结论</strong>：对于程序中大量存在的重复字符串，使用intern( )可以节省内存空间</p>\n<h4 id=\"StringTable-的垃圾回收\"><a href=\"#StringTable-的垃圾回收\" class=\"headerlink\" title=\"StringTable 的垃圾回收\"></a>StringTable 的垃圾回收</h4><ul>\n<li>参数<ul>\n<li><code>-XX:+PrintStringTableStatistics</code></li>\n<li><code>-XX:+PrintGCDetails</code></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intern</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"G1中的-String-去重操作\"><a href=\"#G1中的-String-去重操作\" class=\"headerlink\" title=\"G1中的 String 去重操作\"></a>G1中的 String 去重操作</h4><ul>\n<li>背景：对许多Java应用（有大也有小的）做的测试得出以下结果：<ul>\n<li>堆存活数据集合里面String对象占了25%</li>\n<li>堆存活数据集合里面重复的String对象有13.5%</li>\n<li>String对象的平均长度是45</li>\n</ul>\n</li>\n<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里差不多一半String对象是重复的，重复的意思是：<ul>\n<li>string1.equals(string2) &#x3D; true 。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>\n</ul>\n</li>\n<li>实现：<ul>\n<li>当垃圾收集器工作时，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li>\n<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>\n<li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>\n<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>\n<li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li>\n</ul>\n</li>\n<li>命令开启：<ul>\n<li><code>UseStringDeduplication (bool)</code>：开启去重，默认不开启</li>\n<li><code>PrintStringDeduplicationStatistics (bool)</code>：打印详细去重统计信息</li>\n<li><code>StringDeduplicationAgeThreshold (uintx)</code>：达到这个年龄的String对象被认为是去重的候选对象。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"面试提要：对象实例化\"><a href=\"#面试提要：对象实例化\" class=\"headerlink\" title=\"面试提要：对象实例化\"></a>面试提要：对象实例化</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 创建对象的方式</p></blockquote>\n<ol>\n<li>new<ul>\n<li>最常见的方式</li>\n<li>变形1：Xxx的静态方法</li>\n<li>变形2：XxxBuilder&#x2F;XxxFactory的静态方法</li>\n</ul>\n</li>\n<li>Class的newInstance( ) ：反射的方式，只能调用空参构造器，权限必须是public</li>\n<li>Constructor的newInstance( Xxx )：反射的方式，可以调用空参或带参的构造器，权限没有要求。</li>\n<li>使用clone( )：不需要任何构造器，需要当前类实现Cloneable接口，实现clone( )</li>\n<li>使用反序列化：从文件中、网络中获取对象的二进制流</li>\n<li>使用第三方库Objenesis</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>创建对象的步骤</p></blockquote>\n<ol>\n<li><strong>判断对象对应的类是否加载、链接、初始化</strong><ul>\n<li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（存在则进入第二步）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li>\n</ul>\n</li>\n<li><strong>为对象分配内存</strong>：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。<ul>\n<li>如果内存规整–指针碰撞（Bump The Pointer）<ul>\n<li>所有用过的内存在一边，空闲的内存在一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一小段与对象大小相等的距离。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机将采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。</li>\n</ul>\n</li>\n<li>如果内存不规整–空闲列表分配<ul>\n<li>虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容，这种分配方式称为“空闲列表（Free List）”</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>处理并发安全问题</strong> ×<ul>\n<li>采用CAS失败重试、区域加锁保证更新的原子性</li>\n<li>每个线程预先分配一块TLAB——通过<code>-XX:+/-UseTLAB</code>参数来设置</li>\n</ul>\n</li>\n<li><strong>初始化分配到的空间</strong><ul>\n<li>成员属性设置默认值，保证对象实例字段在不赋值时可以直接使用</li>\n</ul>\n</li>\n<li><strong>设置对象的对象头</strong><ul>\n<li>将对象的所属类（类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li>\n</ul>\n</li>\n<li><strong>执行init方法进行初始化</strong><ul>\n<li>在Java程序的视角来看，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内存对象的首地址赋值给引用变量。</li>\n<li>因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用 的对象才算创建出来</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h4><h5 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h5><p>包含两部分；如果是数组，还需记录数组的长度。</p>\n<ol>\n<li>运行时元数据（Mark Word）<ul>\n<li>哈希值（HashCode）</li>\n<li>GC分代年龄</li>\n<li>帧状态标志</li>\n<li>线程持有的锁</li>\n<li>偏向进程ID</li>\n<li>偏向时间戳</li>\n</ul>\n</li>\n<li>类型指针 KClass<ul>\n<li>指向类元数据InstanceKlass，确定该对象所属的类型</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"实例数据\"><a href=\"#实例数据\" class=\"headerlink\" title=\"实例数据\"></a>实例数据</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p></blockquote>\n<ol>\n<li>相同宽度的字段总是被分配在一起；</li>\n<li>父类中定义的变量会出现在子类之前；</li>\n<li>如果CompactFields参数为true（默认true）：子类的窄变量可能插入到父类变量的空隙</li>\n</ol>\n<h5 id=\"对齐填充（Padding）\"><a href=\"#对齐填充（Padding）\" class=\"headerlink\" title=\"对齐填充（Padding）\"></a>对齐填充（Padding）</h5><p>不是必须的，也没有特殊含义，仅仅起到占位符的作用</p>\n<h5 id=\"小结：图示\"><a href=\"#小结：图示\" class=\"headerlink\" title=\"小结：图示\"></a>小结：图示</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu10906.png\" alt=\"截屏2021-09-23下午1.09.06\"></p>\n<h3 id=\"面试提要：对象访问定位\"><a href=\"#面试提要：对象访问定位\" class=\"headerlink\" title=\"面试提要：对象访问定位\"></a>面试提要：对象访问定位</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu11819.png\" alt=\"截屏2021-09-23下午1.18.19\"></p>\n<p> 定位，通过栈上reference访问</p>\n<h4 id=\"对象访问的两种方式\"><a href=\"#对象访问的两种方式\" class=\"headerlink\" title=\"对象访问的两种方式\"></a>对象访问的两种方式</h4><h5 id=\"句柄访问\"><a href=\"#句柄访问\" class=\"headerlink\" title=\"句柄访问\"></a>句柄访问</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu12114.png\" alt=\"截屏2021-09-23下午1.21.14\"> </p>\n<p>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要移动。</p>\n<h5 id=\"直接访问（HostSpot采用）\"><a href=\"#直接访问（HostSpot采用）\" class=\"headerlink\" title=\"直接访问（HostSpot采用）\"></a>直接访问（HostSpot采用）</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu12222.png\" alt=\"截屏2021-09-23下午1.22.22\"></p>\n<p>优点：节省空间，速度快。</p>\n<h3 id=\"简介：直接内存\"><a href=\"#简介：直接内存\" class=\"headerlink\" title=\"简介：直接内存\"></a>简介：直接内存</h3><ul>\n<li>直接内存是在Java堆外的、直接向系统申请的内存空间。</li>\n<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li>\n<li>通常，访问直接内存的速度会优于Java堆，即可读性能高。<ul>\n<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>\n<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu43220.png\" alt=\"截屏2021-09-23下午4.32.20\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210923-xia-wu43310.png\" alt=\"截屏2021-09-23下午4.33.10\"></p>\n<ul>\n<li>也可能导致OutOfMemoryError异常</li>\n<li>由于直接内存存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>\n<li>缺点<ul>\n<li>分配回收成本较高</li>\n<li>不受JVM内存回收管理</li>\n</ul>\n</li>\n<li>直接内存大小可以通过MaxDirectMemorySize这只</li>\n<li>如果不指定，默认与堆的最大值-Xmx参数值一致</li>\n</ul>\n<h2 id=\"本地方法接口\"><a href=\"#本地方法接口\" class=\"headerlink\" title=\"本地方法接口\"></a>本地方法接口</h2><h3 id=\"什么是本地方法？\"><a href=\"#什么是本地方法？\" class=\"headerlink\" title=\"什么是本地方法？\"></a>什么是本地方法？</h3><p>简单的讲，<strong>一个 Native Method 就是一个Java调用非Java代码的接口。</strong>一个Native Method就是这样一个Java方法；该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都有这一机制，比如在C++中，可以使用extern “C” 告知编译器去调用一个C的函数</p>\n<p>“A native method is a Java Method whose implmentation is provided by non-java code”</p>\n<p>在定义一个native method时，并不提供实现体（有些像定义一个Javainterface），因为其实现体是由非Java语言在外面实现的。</p>\n<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是为了结合 C&#x2F;C++ 程序</p>\n<h3 id=\"为什么要使用-Native-Method？\"><a href=\"#为什么要使用-Native-Method？\" class=\"headerlink\" title=\"为什么要使用 Native Method？\"></a>为什么要使用 Native Method？</h3><p>Java使用非常方便，然而有些层次的任务用Java实现起来不容器，或者程序效率不够理想，那么问题就来了。</p>\n<ul>\n<li><strong>与Java环境外交互</strong></li>\n</ul>\n<p>有时Java应用需要与Java外面的环境交互，这就是本地方法存在的主要原因。你可以想象Java需要一些与底层系统，如操作系统或某些硬件交换信息时的情况，本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐细节。</p>\n<ul>\n<li><strong>与操作系统交互</strong></li>\n</ul>\n<p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用Java实现了jre的底层系统的交互，甚至JVM的一些部分就是用C编写的。</strong>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特征时，我们也需要使用本地方法。</p>\n<ul>\n<li><strong>Sun’s Java</strong></li>\n</ul>\n<p><strong>Sun的解释器使用C实现的，这使得它能像一些普通的C一样与外部交互。</strong>jre大部分使用Java实现的，它也通过一些本地方法与外界交互。例如，类java.lang.Thread的 setPriority( ) 方法使用Java实现的，但是它实现调用的是该类里的本地方法 setPriority0( )。这个本地方法是由C实现的，并被置入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win 32 SetPriority( ) API。这是一个本地方法的具体实现，由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，ranhoubeiJVM调用。</p>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业及应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>\n<h2 id=\"重点：垃圾回收器\"><a href=\"#重点：垃圾回收器\" class=\"headerlink\" title=\"重点：垃圾回收器\"></a>重点：垃圾回收器</h2><h3 id=\"垃圾回收概述\"><a href=\"#垃圾回收概述\" class=\"headerlink\" title=\"垃圾回收概述\"></a>垃圾回收概述</h3><h4 id=\"什么是垃圾\"><a href=\"#什么是垃圾\" class=\"headerlink\" title=\"什么是垃圾\"></a>什么是垃圾</h4><ul>\n<li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong></li>\n</ul>\n<h4 id=\"为什么需要GC\"><a href=\"#为什么需要GC\" class=\"headerlink\" title=\"为什么需要GC\"></a>为什么需要GC</h4><ul>\n<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>\n<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的另一端，以便JVM将整理出的内存分配给新的对象。</li>\n<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>\n</ul>\n<h4 id=\"早期垃圾回收\"><a href=\"#早期垃圾回收\" class=\"headerlink\" title=\"早期垃圾回收\"></a>早期垃圾回收</h4><ul>\n<li>在早起的C&#x2F;C++时代，垃圾回收基本上是手工进行的，开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</li>\n<li><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210925-xia-wu93311.png\" alt=\"截屏2021-09-25下午9.33.11\"></li>\n<li>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所消耗内存可能持续上升，直到出现内存溢出并造成程序崩溃。</li>\n<li><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210925-xia-wu93756.png\" alt=\"截屏2021-09-25下午9.37.56\"></li>\n</ul>\n<h4 id=\"Java垃圾回收机制\"><a href=\"#Java垃圾回收机制\" class=\"headerlink\" title=\"Java垃圾回收机制\"></a>Java垃圾回收机制</h4><ul>\n<li>自动内存管理，无需开发人员手动参与内存分配与回收，这样降低内存泄漏和内存溢出的风险</li>\n<li>自动内存管理，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li>\n</ul>\n<hr>\n<ul>\n<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，<strong>最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></li>\n<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术</li>\n</ul>\n<hr>\n<ul>\n<li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。<ul>\n<li>其中，<strong>Java堆是垃圾收集器的工作重点。</strong></li>\n</ul>\n</li>\n<li>从次数上来讲：<ul>\n<li><strong>频繁收集Young区</strong></li>\n<li><strong>较少收集Old区</strong></li>\n<li><strong>基本不动Perm区（元空间）</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"垃圾回收相关算法\"><a href=\"#垃圾回收相关算法\" class=\"headerlink\" title=\"垃圾回收相关算法\"></a>垃圾回收相关算法</h3><h4 id=\"标记阶段：引用计数算法\"><a href=\"#标记阶段：引用计数算法\" class=\"headerlink\" title=\"标记阶段：引用计数算法\"></a>标记阶段：引用计数算法</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>垃圾标记阶段：对象存活判断</p></blockquote>\n<ul>\n<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活的对象，哪些是已经死亡的对象，只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们称之为<strong>垃圾标记阶段</strong>。</li>\n<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li>\n<li>判断对象存活一般有两种方式：<strong>引用计数算法</strong> 和 <strong>可达性分析算法</strong>。</li>\n</ul>\n<h5 id=\"引用计数算法概述\"><a href=\"#引用计数算法概述\" class=\"headerlink\" title=\"引用计数算法概述\"></a>引用计数算法概述</h5><ul>\n<li>引用计数算法（Reference Counting）比较简单，<strong>对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</strong></li>\n<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加一；当引用失效就减一。当为0时，即表示对象A不可能再被使用，可进行回收。</li>\n<li>优点：<strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</strong></li>\n<li>缺点：<ul>\n<li>它需要单独的字段存储计数器，增加了存储空间的开销。</li>\n<li>每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销。</li>\n<li>引用计数器有一个严重的问题，即无法处理循环引用的情况，这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210926-shang-wu114248.png\" alt=\"截屏2021-09-26上午11.42.48\"></p>\n<h5 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h5><ul>\n<li>引用计数算法，是很多语言党的资源回收选择，例如Python，它更是同时支持引用计数和垃圾收集机制。</li>\n<li>具体哪种最优还是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>\n<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>\n<li>Python 如何解决？<ul>\n<li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li>\n<li>使用弱引用 weakref，weakref是 Python 提供的标准库，旨在解决循环引用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"标记阶段：可达性分析算法\"><a href=\"#标记阶段：可达性分析算法\" class=\"headerlink\" title=\"标记阶段：可达性分析算法\"></a>标记阶段：可达性分析算法</h4><h5 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h5><ul>\n<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以<strong>有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</strong></li>\n<li>相较于引用计数算法，这里的可达性分析就是 <strong>Java、C#</strong> 选择的。这种类型的垃圾收集通常也叫做<strong>追踪性垃圾收集（Tracing Garbage Collection）。</strong></li>\n<li>所谓“GC Roots”根集合就是一组必须活跃的引用。</li>\n<li>基本思路：<ul>\n<li><strong>可达性分析算法是以跟对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</strong>。</li>\n<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong></li>\n<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。</li>\n<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"GC-Roots\"><a href=\"#GC-Roots\" class=\"headerlink\" title=\"GC Roots\"></a>GC Roots</h5><p>在Java 语言中，GC Roots包括以下几类元素：</p>\n<ul>\n<li>虚拟机中栈中引用的对象<ul>\n<li>比如：各个线程被调用的方法中使用到的<strong>参数、局部变量</strong>等。</li>\n</ul>\n</li>\n<li><strong>本地方法栈内JNI（通常说的本地方法）引用的对象</strong></li>\n<li>堆中类静态属性引用的对象<ul>\n<li>比如：<strong>Java 类的引用类型静态变量</strong></li>\n</ul>\n</li>\n<li>方法区中常量引用的对象<ul>\n<li>比如：<strong>字符串常量池（String Table）里的引用</strong></li>\n</ul>\n</li>\n<li>所有被同步锁synchronized持有的对象</li>\n<li>Java虚拟机内部的引用。<ul>\n<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>\n</ul>\n</li>\n<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>\n</ul>\n<hr>\n<ul>\n<li>除了这些固定的GC Roots以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）。<ul>\n<li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被去其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>\n</ul>\n</li>\n<li>小技巧：<ul>\n<li>由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li>\n<li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li>\n</ul>\n<h4 id=\"对象的-finalization-机制\"><a href=\"#对象的-finalization-机制\" class=\"headerlink\" title=\"对象的 finalization 机制\"></a>对象的 finalization 机制</h4><ul>\n<li>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</li>\n<li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize( )方法。</li>\n<li>finalize( ) 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常这个方法中进行一些资源释放和清理的工作，比如关闭文件套接字和数据库连接等等。</li>\n<li>永远不要主动调用 finalize( )方法，应该交给垃圾回收机制调用。理由包括以下三点：<ul>\n<li>finalize( ) 可能导致对象复活</li>\n<li>finalize( ) 方法的执行时间是没有保证的，它完全由GC线程决定，极端情况下，若不发生GC，则 finalize( ) 方法没有执行机会。</li>\n<li>一个糟糕的 finalize( )会严重影响GC性能。</li>\n</ul>\n</li>\n<li>从功能上来说， finalze( ) 方法与C++中的析构函数比较类似，但是Java所采用的是基于垃圾回收器的自动内存管理机制，所以 finalize( )方法在本质上不同于C++中的析构函数。</li>\n<li>由于finalize( )方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong>。</li>\n</ul>\n<hr>\n<ul>\n<li>如果从所有的根节点都无法访问某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己，</strong>如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态，如下：<ul>\n<li><strong>可触及的</strong>：从根节点开始，可以到达这个对象</li>\n<li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 finalize( ) 中复活。</li>\n<li><strong>不可触及的</strong>：对象的 finalize( )被调用，并且没有复活，那么就会进入不可触及状态，不可触及状态的对象不可能复活，因为 finalize( )方法只调用一次。</li>\n</ul>\n</li>\n<li>以上三种状态中，由于 finalize( )方法的存在，进行的区分，只有在对象不可触及时才可以被回收。</li>\n</ul>\n<hr>\n<ul>\n<li>判定一个对象objA是否可回收，至少要经历两次标记过程：<ol>\n<li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li>\n<li>进行筛选，判断此对象是否有必要执行 finalize( )方法<ol>\n<li>如果对象objA没有重写 finalize( )方法，或者 finalize( )方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>\n<li>如果对象objA重写了 finalize( )，且还未执行过，那么objA会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其 finalize( )方法执行。</li>\n<li>finalize( )方法是对象逃脱死亡的<strong>最后且唯一</strong>一次机会，稍后GC会对 F-Queue 队列中的对象进行第二次标记。如果 objA在 finalize( )方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移除“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被在此调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize 方法只会被调用一次。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<p><code>-XX:+HeapDumpOnOutOfMemoryError</code>:堆空间内存溢出快照</p>\n<h4 id=\"清除阶段：标记-清除算法\"><a href=\"#清除阶段：标记-清除算法\" class=\"headerlink\" title=\"清除阶段：标记-清除算法\"></a>清除阶段：标记-清除算法</h4><p>常见的三种垃圾收集算法是：<strong>标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>背景</p></blockquote>\n<p>标记 - 清除算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>执行过程</p></blockquote>\n<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（stop the world），然后进行两项工作：</p>\n<ul>\n<li>标记：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象（非垃圾对象）</strong>。一般是在对象的Header中记录为可达对象。</li>\n<li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>缺点</p></blockquote>\n<ul>\n<li><strong>效率不高</strong></li>\n<li><strong>在进行GC时，需要停止整个应用程序，导致用户体验差</strong></li>\n<li><strong>这种方式清理出来的空闲内存是不连续的，会产生内存碎片。需要维护一个空闲列表。</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：何为清除？</p></blockquote>\n<ul>\n<li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</li>\n</ul>\n<h4 id=\"清除阶段：复制算法\"><a href=\"#清除阶段：复制算法\" class=\"headerlink\" title=\"清除阶段：复制算法\"></a>清除阶段：复制算法</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>背景</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210927-xia-wu120915.png\" alt=\"截屏2021-09-27下午12.09.15\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>核心思想</p></blockquote>\n<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>优点</p></blockquote>\n<ul>\n<li>没有标记和清除过程，实现简单，运行高效</li>\n<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>缺点</p></blockquote>\n<ul>\n<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>\n<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>特别的</p></blockquote>\n<ul>\n<li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>应用场景</p></blockquote>\n<p>在新生代，对常规应用的垃圾回收，一词通常可以到达70%~99%的内存空间，回收性价比很高，所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>\n<h4 id=\"清除阶段：标记-压缩算法\"><a href=\"#清除阶段：标记-压缩算法\" class=\"headerlink\" title=\"清除阶段：标记-压缩算法\"></a>清除阶段：标记-压缩算法</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>背景</p></blockquote>\n<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的，这种情况在新生代经常使用，但是在老年代，更常见的情况是大部分对象都是存活对象，如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他算法。</strong></p>\n<p>标记 - 清除算法的确可以应用在老年代中，但是该算法不仅执行效率底下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础上进行改进。标记 - 压缩 算法由此诞生。</p>\n<p>1970年前后，G.L.Steele、C.J.Chene和D.S.Wise等研究者发布 标记 - 压缩 算法。在许多现代的垃圾收集器中，很多都是用了 标记 - 压缩算法或其他改进版本。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>执行过程</p></blockquote>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210927-xia-wu52013.png\" alt=\"截屏2021-09-27下午5.20.13\"></p>\n<p>标记 - 压缩算法的最终效果等同于 标记 - 清除算法执行完后，再进行一次内存碎片整理，因此，也可以把它称为 <strong>标记 - 清除 - 压缩（Mark-Sweep-Compact）算法</strong>。</p>\n<p>二者的本质差异在于<strong>标记 - 清除算法是一种非移动式的回收算法，标记 - 压缩是移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p>\n<p>可以看到，标记的存活对象会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉，如此依赖，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了很多开销。 </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 优点</p></blockquote>\n<ul>\n<li>消除了 标记 - 清除算法中，内存区域分散的缺点，我们需要给对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>\n<li>消除了复制算法中，内存减半的空间代价。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>缺点</p></blockquote>\n<ul>\n<li>从效率上来说，标记 - 整理算法要低于复制算法。</li>\n<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>\n<li>移动过程中，需要STW</li>\n</ul>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210927-xia-wu53004.png\" alt=\"截屏2021-09-27下午5.30.04\"></p>\n<h4 id=\"GC分代收集\"><a href=\"#GC分代收集\" class=\"headerlink\" title=\"GC分代收集\"></a>GC分代收集</h4><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210927-xia-wu54249.png\" alt=\"截屏2021-09-27下午5.42.49\"></p>\n<h4 id=\"增量收集算法\"><a href=\"#增量收集算法\" class=\"headerlink\" title=\"增量收集算法\"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop The World 的的状态，在Stop The World 状态下，应用程序所有的线程都会被挂起，暂停一切工作，等待垃圾回收工作的完成。如果该时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究诞生了 增量收集算法（Incremental Collecting）。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 基本思想</p></blockquote>\n<p>如果一次性将所有的垃圾进行处理，需要造成的系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替进行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></p>\n<p>总的来说，增量收集算法的基础仍然是传统的标记 - 清除和复制算法。增量收集算法<strong>通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</strong></p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>使用这种方式，由于在垃圾回收过程中，间断性地还会执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降。</strong></li>\n</ul>\n<h4 id=\"分区收集算法\"><a href=\"#分区收集算法\" class=\"headerlink\" title=\"分区收集算法\"></a>分区收集算法</h4><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长，为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>\n<p>分代算法将按照对象的生命周期长短划分为两个部分，分区算法将整个堆空间划分成连续的不同小区间 region。</p>\n<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210927-xia-wu60435.png\" alt=\"截屏2021-09-27下午6.04.35\" style=\"zoom:50%;\" />\n\n\n\n<h3 id=\"垃圾回收相关概念\"><a href=\"#垃圾回收相关概念\" class=\"headerlink\" title=\"垃圾回收相关概念\"></a>垃圾回收相关概念</h3><h4 id=\"System-gc-的理解\"><a href=\"#System-gc-的理解\" class=\"headerlink\" title=\"System.gc( )的理解\"></a>System.gc( )的理解</h4><ul>\n<li><strong>在默认情况下，通过System.gc( )或者Runtime.getRuntime( ).gc( )的调用，会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li>\n<li>然而 System.gc( )调用附带一个免责声明，无法保证对垃圾收集器的调用。</li>\n<li>JVM实现者可以通过 System.gc( )调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则过于麻烦。在一些特殊情况下，比如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc( )</li>\n</ul>\n<h4 id=\"垃圾回收的并行与并发\"><a href=\"#垃圾回收的并行与并发\" class=\"headerlink\" title=\"垃圾回收的并行与并发\"></a>垃圾回收的并行与并发</h4><h5 id=\"并发（Concurrent）\"><a href=\"#并发（Concurrent）\" class=\"headerlink\" title=\"并发（Concurrent）\"></a>并发（Concurrent）</h5><ul>\n<li>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</li>\n<li>并发并不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时进行。</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-shang-wu120034.png\" alt=\"截屏2021-09-28上午12.00.34\" style=\"zoom:50%;\" />\n\n<h5 id=\"并行（Parallel）\"><a href=\"#并行（Parallel）\" class=\"headerlink\" title=\"并行（Parallel）\"></a>并行（Parallel）</h5><ul>\n<li>当系统有一个以上的CPU时，某一个 CPU执行一个进程时，另一个CPU可以执行另外一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。</li>\n<li>其实决定并行的因素并不是CPU的数量，而是CPU核心数量，比如一个CPU多个核也可以并行。</li>\n<li>适合科学计算，后台处理等弱交互场景</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-shang-wu120437.png\" alt=\"截屏2021-09-28上午12.04.37\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"二者对比\"><a href=\"#二者对比\" class=\"headerlink\" title=\"二者对比\"></a>二者对比</h5><p>并发，指的是多个事情，在同一时间段内同时发生了。<br>并行，指的是多个事情，在同一时间点上同时发生了。</p>\n<p>并发的多个任务之间是相互抢占资源的。<br>并行的多个任务之间是互不抢占资源的。</p>\n<p>只有多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>\n<h5 id=\"垃圾回收的并发与并行\"><a href=\"#垃圾回收的并发与并行\" class=\"headerlink\" title=\"垃圾回收的并发与并行\"></a>垃圾回收的并发与并行</h5><ul>\n<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul>\n<li>如 ParNew、Parallel Scavenge、 Parallel Old；</li>\n</ul>\n</li>\n<li>串行（Serial）<ul>\n<li>相较于并行的概念，单线程执行。</li>\n<li>若果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>\n</ul>\n</li>\n<li>并发（Concurrent）：<strong>指用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul>\n<li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li>\n<li>如：CMS、G1</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"安全点与安全区域\"><a href=\"#安全点与安全区域\" class=\"headerlink\" title=\"安全点与安全区域\"></a>安全点与安全区域</h4><h5 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h5><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有特定的位置才能停下来开始GC，这些位置称为“安全点（Safepoint）”。</p>\n<p>Safe Point 的选择很重要，<strong>如果太少可能会导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。</strong>大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p></blockquote>\n<ul>\n<li>抢先式中断：（目前没有虚拟机采用了）</li>\n</ul>\n<p>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p>\n<ul>\n<li>主动式中断：</li>\n</ul>\n<p>如果设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。 </p>\n<h6 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h6><p>Safepoint 机制保证了程序执行时，在很短的时间内就会遇到可进入GC的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能被等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>\n<p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何位置开始GC都是安全的。</strong>我们也可以把 Safe Region看做是被扩展了的 Safepoint。</p>\n<p><strong>实际执行时：</strong></p>\n<ol>\n<li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM会忽略标识为 Safe Region状态的线程；</li>\n<li>当线程即将离开 Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等代直到收到可以安全离开 Safe Region 的信号为止。</li>\n</ol>\n<h4 id=\"再谈引用\"><a href=\"#再谈引用\" class=\"headerlink\" title=\"再谈引用\"></a>再谈引用</h4><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>\n<p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>\n<p>在JDK 1.2 版本之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这四种引用强度依次减弱。</p>\n<p>除强引用外，其他3种引用均可以在java.lang.ref包中找到，如下图，显示了这三种引用类型对应的类，开发人员可以在程序中直接使用。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-shang-wu110501.png\" alt=\"截屏2021-09-28上午11.05.01\" style=\"zoom:50%;\" />\n\n\n\n<p>Reference 子类中只有终结器引用是包内可见的，其他3种引用类型均为 public ，可以在应用程序中直接使用</p>\n<ul>\n<li><strong>强引用（StrongReference）</strong>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj &#x3D; new Object ( )”这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li>\n<li><strong>软引用（SoftReference）</strong>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>\n<li><strong>弱引用（WeakReference）</strong>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>\n<li><strong>虚引用（PhantomReference）</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>\n</ul>\n<h5 id=\"强引用（Strong-Reference）-–-不回收\"><a href=\"#强引用（Strong-Reference）-–-不回收\" class=\"headerlink\" title=\"强引用（Strong Reference） – 不回收\"></a>强引用（Strong Reference） – 不回收</h5><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也就是默认的引用类型。</p>\n<p>当在Java中使用 new 关键字创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>\n<p><strong>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong></p>\n<p>对于一个普通的对象，如果没有其它应用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>\n<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。<strong>所以，强引用是造成Java内存泄漏的主要原因之一。</strong></p>\n<h5 id=\"软引用（Soft-Reference）-–-内存不足即回收\"><a href=\"#软引用（Soft-Reference）-–-内存不足即回收\" class=\"headerlink\" title=\"软引用（Soft Reference） – 内存不足即回收\"></a>软引用（Soft Reference） – 内存不足即回收</h5><p>软引用是用来描述一些还有用，但非必要的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这回收仍然没有足够内存，则会抛出OOM异常。</p>\n<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，以保证程序正常进行。</p>\n<p>垃圾回收器在某个时刻决定回收软件可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>\n<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间更长一些，迫不得已才清理。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu11521.png\" alt=\"截屏2021-09-28下午1.15.21\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"弱引用（Weak-Referenc）-–-发现即回收\"><a href=\"#弱引用（Weak-Referenc）-–-发现即回收\" class=\"headerlink\" title=\"弱引用（Weak Referenc） – 发现即回收\"></a>弱引用（Weak Referenc） – 发现即回收</h5><p>弱引用也是用来描述那些非必要对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</strong>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>\n<p>但是，由于垃圾回收器的线程优先级非常低，因此，并不一定能很快地发现持有弱引用的对象。<strong>在这种情况下，弱引用对象可以存在较长的时间。</strong></p>\n<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>\n<p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>，如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出，而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而加速程序运行。</p>\n<h5 id=\"虚引用（Phantom-Reference）-–-对象回收跟踪\"><a href=\"#虚引用（Phantom-Reference）-–-对象回收跟踪\" class=\"headerlink\" title=\"虚引用（Phantom Reference） – 对象回收跟踪\"></a>虚引用（Phantom Reference） – 对象回收跟踪</h5><p>也成为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>\n<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可以被垃圾回收器回收。</p>\n<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当时图通过虚引用的 get( ) 方法获得对象时，总是 null。</p>\n<p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被回收时收到一个系统通知。</strong></p>\n<ul>\n<li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li>\n<li><strong>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</strong></li>\n<li>在JDK 1.2之后提供了 PhantomReference 类来实现虚引用。</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu13507.png\" alt=\"截屏2021-09-28下午1.35.07\" style=\"zoom:50%;\" />\n\n<p>NIO中缓冲区的 allocateDirect() 方法中就使用了虚引用，其中直接内存的分配是调用 Unsafe 对象的 allocateMemory 方法来分配直接内存，其中的 Cleaner 是该缓冲区的虚引用对象</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/image20220203143418256.png\" alt=\"image-20220203143418256\" style=\"zoom:50%;\" />\n\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/image20220203143429366.png\" alt=\"image-20220203143429366\"></p>\n<h5 id=\"终结器引用（Final-Reference）\"><a href=\"#终结器引用（Final-Reference）\" class=\"headerlink\" title=\"终结器引用（Final Reference）\"></a>终结器引用（Final Reference）</h5><ul>\n<li>它用以实现对象的 finalize( ) 方法，也可以称为终结器引用</li>\n<li>无需手动编码，其内部配合引用队列使用</li>\n<li>在GC时，终结器引用入队，由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize( )方法，第二次GC时才能回收被引用对象。</li>\n</ul>\n<h3 id=\"垃圾回收器-实现\"><a href=\"#垃圾回收器-实现\" class=\"headerlink\" title=\"垃圾回收器 - 实现\"></a>垃圾回收器 - 实现</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>概述</p></blockquote>\n<ul>\n<li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同的版本的JVM来实现。</li>\n<li>由于JDK的版本处于高速迭代的过程中，因此Java发展至今已经衍生了众多的GC。</li>\n<li>从不同角度分析垃圾收集器，可以将其分为不同的类型。</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu34104.png\" alt=\"截屏2021-09-28下午3.41.04\" style=\"zoom:50%;\" />\n\n<ul>\n<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>\n<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能可以超过并行回收器和并发回收器。<strong>所以，串行回收默认被应用在客户端的Client模式下的JVM中</strong></li>\n<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>\n</ul>\n</li>\n<li>并行收集可以运用多个CPU同时执行垃圾回收，因此1提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，存在STW。</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu34838.png\" alt=\"截屏2021-09-28下午3.48.38\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu35005.png\" alt=\"截屏2021-09-28下午3.50.05\" style=\"zoom:50%;\" />\n\n\n\n<h4 id=\"GC分类与性能指标\"><a href=\"#GC分类与性能指标\" class=\"headerlink\" title=\"GC分类与性能指标\"></a>GC分类与性能指标</h4><ul>\n<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong><ul>\n<li>总运行时间：程序运行的时间 + 内存回收时间</li>\n</ul>\n</li>\n<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li>\n<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</strong></li>\n<li>收集频率：相对于应用程序的执行，手机操作发生的频率</li>\n<li><strong>内存占用：Java堆区所占的内存大小</strong></li>\n<li>快速：一个对象从诞生到被回收所经历的时间</li>\n</ul>\n<hr>\n<ul>\n<li>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>\n<li>这三项里，暂停时间的重要性日益凸显，因为随着硬件发展，内存占用多些越来越能容忍，硬件性能提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>\n<li>简单来说，主要抓两点：<ul>\n<li>吞吐量、暂停时间</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"评估GC的性能指标：吞吐量（throughput）\"><a href=\"#评估GC的性能指标：吞吐量（throughput）\" class=\"headerlink\" title=\"评估GC的性能指标：吞吐量（throughput）\"></a>评估GC的性能指标：吞吐量（throughput）</h5><ul>\n<li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F; （运行用户代码时间 + 垃圾收集时间）。<ul>\n<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是 99%。</li>\n</ul>\n</li>\n<li>这种情况下，应用程序能容忍较高的暂停时间，因此从，高吞吐量的的应用程序有更长的时间基准，快速响应是不必考虑的。</li>\n<li><strong>吞吐量优先，意味着在单位时间内，STW时间最短： 0.2 + 0.2 &#x3D; 0.4</strong></li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu55437.png\" alt=\"截屏2021-09-28下午5.54.37\" style=\"zoom:50%;\" />\n\n<h5 id=\"评估GC的性能指标：暂停时间（pause-time）\"><a href=\"#评估GC的性能指标：暂停时间（pause-time）\" class=\"headerlink\" title=\"评估GC的性能指标：暂停时间（pause time）\"></a>评估GC的性能指标：暂停时间（pause time）</h5><ul>\n<li>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态<ul>\n<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</li>\n</ul>\n</li>\n<li><strong>暂停时间优先，意味着尽可能让单次STW时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</strong></li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu55816.png\" alt=\"截屏2021-09-28下午5.58.16\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"吞吐量-vs-暂停时间\"><a href=\"#吞吐量-vs-暂停时间\" class=\"headerlink\" title=\"吞吐量 vs 暂停时间\"></a>吞吐量 vs 暂停时间</h5><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu60110.png\" alt=\"截屏2021-09-28下午6.01.10\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu60136.png\" alt=\"截屏2021-09-28下午6.01.36\" style=\"zoom:50%;\" />\n\n\n\n<h4 id=\"不同的垃圾回收器概述\"><a href=\"#不同的垃圾回收器概述\" class=\"headerlink\" title=\"不同的垃圾回收器概述\"></a>不同的垃圾回收器概述</h4><h5 id=\"垃圾收集器发展史\"><a href=\"#垃圾收集器发展史\" class=\"headerlink\" title=\"垃圾收集器发展史\"></a>垃圾收集器发展史</h5><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为 Garbage Collector。</p>\n<ul>\n<li>1999年随着JDK1.3.1 一起来的是串行方式的 Serial GC，它是第一款GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本。</li>\n<li>2002年2月26日，Parallel GC和 Concurrent Mark Sweep GC跟随 JDK1.4.2一起发布</li>\n<li>Parallel GC 在JDK1.6之后称为HopSpot默认GC</li>\n<li>2012年，在JDK1.7u4版本中，G1可用</li>\n<li>2017年<strong>，JDK9中G1编程默认的垃圾收集器，代替CMS</strong></li>\n<li>2018年3月，JDK10中G1垃圾收集器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>\n<li>2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为“No-Op（无操作）”回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。</li>\n<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC；低停顿时间的GC（Experimental）</li>\n<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>\n<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在 macOS和 Windows上的应用。</li>\n</ul>\n<hr>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu61826.png\" alt=\"截屏2021-09-28下午6.18.26\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu62139.png\" alt=\"截屏2021-09-28下午6.21.39\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu62215.png\" alt=\"截屏2021-09-28下午6.22.15\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu62702.png\" alt=\"截屏2021-09-28下午6.27.02\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"如何查看默认垃圾收集器？\"><a href=\"#如何查看默认垃圾收集器？\" class=\"headerlink\" title=\"如何查看默认垃圾收集器？\"></a>如何查看默认垃圾收集器？</h5><ul>\n<li><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数，包括使用的垃圾收集器</li>\n<li><code>jinfo -flag 相关垃圾回收器参数 进程id</code><ul>\n<li><code>UseParallelGC</code>  &amp;  <code>UseParallelOldGC</code>  &amp;  <code>UseG1GC</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Serial-回收器：串行回收（标记清除）\"><a href=\"#Serial-回收器：串行回收（标记清除）\" class=\"headerlink\" title=\"Serial 回收器：串行回收（标记清除）\"></a>Serial 回收器：串行回收（标记清除）</h4><ul>\n<li>Serial 收集器是最基本、历史最久远的垃圾收集器了。JDK1.3之前回收新生代的唯一选择。</li>\n<li>Serial 收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</li>\n<li><strong>Serial 收集器采用复制算法、串行回收和“Stop-The-World”机制的方式执行内存回收。</strong></li>\n<li>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。<strong>Serial Old收集器同样采用了串行回收和STW机制，只不过内存回收算法上使用的是标记 - 压缩算法。</strong><ul>\n<li>Serial Old是运行在Client模式下默认的老年代垃圾回收器。</li>\n<li>Serial Old在Server模式下主要由两个用途：①与新生代的Parallel Scavenge 配合使用 ②作为老年代CMS收集器的后背垃圾收集方案。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210928-xia-wu70045.png\" alt=\"截屏2021-09-28下午7.00.45\" style=\"zoom:50%;\" />\n\n<ul>\n<li>优势：<strong>简单而高效</strong>（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。<ul>\n<li>运行在Client模式下的虚拟机是个不错的选择。</li>\n</ul>\n</li>\n<li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li>\n<li>在HotSpot虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。<ul>\n<li>等价于 新生代使用 Serial GC，老年代使用 Serial Old GC</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> Serial 总结</p></blockquote>\n<p>这种垃圾收集器了解即可，现在已经不使用了，而且限定在单核CPU才可以用，现在都是多核的。</p>\n<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>\n<h4 id=\"ParNew-回收器：并行回收（复制算法\"><a href=\"#ParNew-回收器：并行回收（复制算法\" class=\"headerlink\" title=\"ParNew 回收器：并行回收（复制算法)\"></a>ParNew 回收器：并行回收（复制算法)</h4><ul>\n<li>由于ParNew 收集器是基于<strong>并行</strong>回收，那么是否可以判定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？<ul>\n<li>ParNew收集器运行在多CPU的环境下，由于可以充分利用CPU、多核心等物理硬件优势，可以更快速地完成垃圾收集，提升程序吞吐量。</li>\n<li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器效率高。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>\n</ul>\n</li>\n<li>除Serial外，目前只有 ParNew GC能与CMS收集器配合工作。</li>\n<li>显式使用：<code>-XX:+UseParNewGC</code></li>\n<li>限制线程数量：<code>-XX:ParallelGCThreads</code>，默认开启和CPU数据相同的线程数</li>\n</ul>\n<h4 id=\"Parallel回收器：吞吐量优先、并行回收（复制算法-标记压缩）\"><a href=\"#Parallel回收器：吞吐量优先、并行回收（复制算法-标记压缩）\" class=\"headerlink\" title=\"Parallel回收器：吞吐量优先、并行回收（复制算法+标记压缩）\"></a>Parallel回收器：吞吐量优先、并行回收（复制算法+标记压缩）</h4><ul>\n<li>HotSpot年轻代中除了拥有ParNew收集器是基于并行回收的以外，<strong>Parallel Scavenge 收集器同样也采用了复制算法、并行回收和“Stop - The - World”机制</strong></li>\n<li>那么Parallel收集器的出现是否多此一举？<ul>\n<li>与ParNew收集器不同，Parallel Scavenge收集器的目标是<strong>达到一个可控制的吞吐量（Throughput）</strong>，它也被称为吞吐量优先的垃圾收集器。</li>\n<li>自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别</li>\n</ul>\n</li>\n<li>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>，因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</li>\n<li>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器</li>\n<li><strong>Parallel Old收集器采用了 标记 - 压缩 算法，同样也是基于并行回收和STW机制。</strong></li>\n<li>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。</li>\n<li>在JDK 8中，作为默认收集器</li>\n</ul>\n<hr>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>参数配置</p></blockquote>\n<ol>\n<li><code>-XX:+UseParallelGC</code>：手动指定使用此<strong>组</strong>收集器</li>\n<li><code>-XX:+UseParallelOldGC</code>：手动指定使用此<strong>组</strong>收集器，效果同上</li>\n<li><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数量影响垃圾收集性能。<ul>\n<li>默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量；大于8个时，其值等于 3 + [ 5*CPU_Count ] &#x2F; 8</li>\n</ul>\n</li>\n<li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器的最大停顿时间（即STW的时间）。单位毫秒<ul>\n<li>为了尽可能的把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>\n<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>\n<li>该参数使用需谨慎</li>\n</ul>\n</li>\n<li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例（ &#x3D; 1 &#x2F; ( N + 1 )）。用于衡量吞吐量的大小<ul>\n<li>取值范围 ( 0 , 100 )。默认99，也就是垃圾回收时间不超过 1%</li>\n<li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定的矛盾性。暂停时间越长，Radio参数就越容易超过设定的比例。</li>\n</ul>\n</li>\n<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有自适应调节策略<ul>\n<li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>\n<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"CMS-回收器：低延迟、并发（标记清除）\"><a href=\"#CMS-回收器：低延迟、并发（标记清除）\" class=\"headerlink\" title=\"CMS 回收器：低延迟、并发（标记清除）\"></a>CMS 回收器：低延迟、并发（标记清除）</h4><ul>\n<li>在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可以认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的 并发 收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></li>\n<li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合做与用户交互的程序，良好的响应速度能提升用户体验。<ul>\n<li><strong>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务器端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</strong></li>\n</ul>\n</li>\n<li>CMS的收集算法采用 标记 - 清除 算法，并且也会STW</li>\n<li>不幸的是，CMS作为老年代的收集器，无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5 中使用CMS来收集老年代色时候，新生代中只能选择ParNew或者Serial中的一个。</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-shang-wu113911.png\" alt=\"截屏2021-09-29上午11.39.11\" style=\"zoom:50%;\" />\n\n<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即 <strong>初始标记阶段、并发标记阶段、重新标记阶段 和 并发清除阶段</strong></p>\n<ul>\n<li><strong>初始标记阶段（Initial - Mark）</strong>：在这个阶段中，程序中所有的工作线程都将会因为STW机制而出现短暂的停顿，这个阶段的任务<strong>仅仅是标记出GC Roots能直接关联到的对象。</strong>一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>\n<li><strong>并发标记阶段（Concurrent - Mark）</strong>：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要暂停用户线程，可以与垃圾收集线程一起并发运行。</li>\n<li><strong>重新标记（Remark）阶段：</strong>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<strong>因此为了修正并发标记期间，因用户程序继续运作而导致的标记变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段时间短。</li>\n<li><strong>并发清除阶段（Concurrent - Sweep）</strong>：<strong>此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。</strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-shang-wu115155.png\" alt=\"截屏2021-09-29上午11.51.55\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-shang-wu115625.png\" alt=\"截屏2021-09-29上午11.56.25\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-shang-wu115753.png\" alt=\"截屏2021-09-29上午11.57.53\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-shang-wu115819.png\" alt=\"截屏2021-09-29上午11.58.19\" style=\"zoom:50%;\" />\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 参数设置</p></blockquote>\n<ul>\n<li><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片问题的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变长了。</li>\n<li><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次Full GC后对内存空间进行压缩整理</li>\n<li><code>-XX:ParallelCMSThreads</code>：设置CMS的线程数量<ul>\n<li>默认：( n + 3 ) &#x2F; 4  ；ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>\n</ul>\n</li>\n<li><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用CMS收集器<ul>\n<li>开启该参数后将会自动将 <code>-XX:+UseParNewGC</code>（Young）打开</li>\n</ul>\n</li>\n<li><code>-XX:CMSlnitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便进行垃圾回收。<ul>\n<li>JDK5及以前的默认值为 68；JDK 6 及以上的默认值为 92</li>\n<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效地降低CMS的触发频率，减少老年代回收的次数可以较为明显的改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应降低这个阈值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数。</strong></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"CMS小结\"><a href=\"#CMS小结\" class=\"headerlink\" title=\"CMS小结\"></a>CMS小结</h5><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-xia-wu122208.png\" alt=\"截屏2021-09-29下午12.22.08\" style=\"zoom:50%;\" />\n\n\n\n\n\n<h4 id=\"G1回收器：区域化分代式\"><a href=\"#G1回收器：区域化分代式\" class=\"headerlink\" title=\"G1回收器：区域化分代式\"></a>G1回收器：区域化分代式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>G1垃圾收集器是一种工作在堆内不同分区上的<u><strong>并发</strong></u>收集器。分区既可以归属于老年代，也可以归属新生代，同一个代的分区不需要保持连续。为老年代设计分区的初衷是我们发现并发后台线程在回收老年代中没有引用的对象时，有的分区垃圾对象的数量很多，另一些分区垃圾对象相对较少。</p>\n<p>虽然分区的垃圾收集工作实际还是要暂停应用线程，不过由于G1收集器专注于垃圾最多的分区，最终的效果是花费较少的时间就能回收这些分区的垃圾。这种只**<u>专注于垃圾最多的分区</u>**的方式就是G1垃圾收集器的名称由来，即首先收集垃圾最多的分区。</p>\n<p>这一算法并不适用新生代的分区，新生代进行垃圾回收时，整个新生代空间要么被回收，要么被晋升。那么新生代也采用分区的原因是因为：采用预定义的分区能够便于代的大小调整。</p></blockquote>\n<p>G1收集器的收集活动包括4种操作：</p>\n<ul>\n<li><strong>新生代垃圾收集；</strong></li>\n<li><strong>后台收集，并发周期；</strong></li>\n<li><strong>混合式垃圾收集；</strong></li>\n<li><strong>以及必要时的Full GC。</strong></li>\n</ul>\n<h5 id=\"G1-特点\"><a href=\"#G1-特点\" class=\"headerlink\" title=\"G1 特点\"></a>G1 特点</h5><ul>\n<li><strong>并行与并发</strong><ul>\n<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</li>\n<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>\n</ul>\n</li>\n<li><strong>分代收集</strong><ul>\n<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆1的结构上来看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或工作在年轻代，或工作在老年代。</li>\n</ul>\n</li>\n<li><strong>空间整合</strong><ul>\n<li>CMS：“标记 - 清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>\n<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看做是 标记 - 压缩（Mark - Compact）算法。这两种算法都可以避免内存碎片，这种特性有利于程序长期运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n</li>\n<li><strong>可预测的停顿时间模型（软实时 soft real - time）</strong><ul>\n<li>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li>\n<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对全局停顿情况的发生也能得到较好的控制。</li>\n<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的的空间大小以及回收所需要的经验值），<strong>在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</strong></li>\n<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"G1-不足\"><a href=\"#G1-不足\" class=\"headerlink\" title=\"G1 不足\"></a>G1 不足</h5><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都比CMS要高。</p>\n<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在 6 - 8 GB之间。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>G1参数设置</p></blockquote>\n<ul>\n<li><code>-XX:+UseG1GC</code>：手动指定使用G1</li>\n<li><code>-XX:G1HeapRegionSize</code>：设置每个Region的大小。值是2的幂，范围是1M~32M，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的 1&#x2F;2000</li>\n<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>\n<li><code>-XX:ParallelGCThread</code>：设置STW工作线程数的值，最大为8</li>\n<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1&#x2F;4 左右。</li>\n<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并GC周期的Java堆占用率阈值，超过此值，就出发GC。默认45</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>G1回收器常见操作步骤</p></blockquote>\n<ol>\n<li>开启G1垃圾收集器</li>\n<li>设置堆的最大内存</li>\n<li>设置最大的停顿时间</li>\n</ol>\n<h6 id=\"G1回收器的使用场景\"><a href=\"#G1回收器的使用场景\" class=\"headerlink\" title=\"G1回收器的使用场景\"></a>G1回收器的使用场景</h6><ul>\n<li><strong>面向服务端应用，针对具有大内存、多处理器的机器</strong>。（在普通大小的堆里表现并太好）</li>\n<li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；<ul>\n<li>如：在堆大小约为6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）</li>\n</ul>\n</li>\n<li>用来替换掉JDK1.5中的CMS收集器；如下情况G1的性能可能更好：<ul>\n<li>超过50%的Java堆被活动数据占用；</li>\n<li>对象分配频率或年代提升频率变化很大；</li>\n<li>GC停顿时间过长（&gt;0.5s）</li>\n</ul>\n</li>\n<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>\n</ul>\n<h5 id=\"分区Region：化整为零\"><a href=\"#分区Region：化整为零\" class=\"headerlink\" title=\"分区Region：化整为零\"></a>分区Region：化整为零</h5><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1~32MB之间，且为2的N次幂。可以通过 <code>-XX:G1HeapRegionSize</code>设定。所有的Region大小相同，且在JVM生命周期内不会改变。</p>\n<p>虽然还保留有新生代与老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-xia-wu73251.png\" alt=\"截屏2021-09-29下午7.32.51\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-xia-wu73611.png\" alt=\"截屏2021-09-29下午7.36.11\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"G1回收垃圾过程\"><a href=\"#G1回收垃圾过程\" class=\"headerlink\" title=\"G1回收垃圾过程\"></a>G1回收垃圾过程</h5><p>G1 GC垃圾回收过程主要包括如下三个环节：</p>\n<ul>\n<li>年轻代GC（Young GC）</li>\n<li>老年代并发标记过程（Concurrent Marking）</li>\n<li>混合回收（Mixed GC）</li>\n<li>如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210929-xia-wu74858.png\" alt=\"截屏2021-09-29下午7.48.58\" style=\"zoom:50%;\" />\n\n<p>应用程序分配内存，<strong>当年轻代的Eden区用尽时开始年轻代回收过程</strong>；G1的年轻代收集阶段是一个<strong>并行的独占式</strong>收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收，<strong>然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</strong></p>\n<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>\n<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描 &#x2F; 回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>\n<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒会新分配大约2G的内存，G1每45秒进行一次年轻代回收，每31小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>\n<h5 id=\"G1回收器垃圾回收过程：Rememberd-Set\"><a href=\"#G1回收器垃圾回收过程：Rememberd-Set\" class=\"headerlink\" title=\"G1回收器垃圾回收过程：Rememberd Set\"></a>G1回收器垃圾回收过程：Rememberd Set</h5><ul>\n<li>一个对象被不同区域引用的问题</li>\n<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li>\n<li>在其他的分代收集器，也存在这样的问题（而G1更突出）</li>\n<li>回收新生代也不得不同时扫描老年代？</li>\n<li>这样的话会降低Minor GC的效率；</li>\n</ul>\n<hr>\n<ul>\n<li>解决方法：<ul>\n<li>无论是G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描；</li>\n<li><strong>每个Region都有一个对应的Remembered Set；</strong></li>\n<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂是中断操作；</li>\n<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</li>\n<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</li>\n<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-shang-wu101127.png\" alt=\"截屏2021-09-30上午10.11.27\" style=\"zoom:50%;\" />\n\n\n\n\n\n<p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，<strong>当Eden空间耗尽时</strong>，G1会启动一次年轻代垃圾回收过程。</p>\n<p>YGC时，首先G1停止应用程序的执行（STW），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。 </p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-shang-wu101939.png\" alt=\"截屏2021-09-30上午10.19.39\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-shang-wu102404.png\" alt=\"截屏2021-09-30上午10.24.04\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-shang-wu102713.png\" alt=\"截屏2021-09-30上午10.27.13\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h5><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-shang-wu102853.png\" alt=\"截屏2021-09-30上午10.28.53\" style=\"zoom:50%;\" />\n\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-shang-wu103458.png\" alt=\"截屏2021-09-30上午10.34.58\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h5><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-shang-wu103535.png\" alt=\"截屏2021-09-30上午10.35.35\" style=\"zoom:50%;\" />\n\n\n\n<h5 id=\"G1回收器优化建议\"><a href=\"#G1回收器优化建议\" class=\"headerlink\" title=\"G1回收器优化建议\"></a>G1回收器优化建议</h5><ul>\n<li>年轻代大小<ul>\n<li>避免使用 <code>-Xmn</code> 或者 <code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>\n<li>固定年轻代大小会覆盖暂停时间目标</li>\n</ul>\n</li>\n<li>暂停时间目标不要过于严苛<ul>\n<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾收集时间</li>\n<li>评估G1 GC吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"垃圾回收器总结\"><a href=\"#垃圾回收器总结\" class=\"headerlink\" title=\"垃圾回收器总结\"></a>垃圾回收器总结</h4><p><a href=\"https://juejin.cn/post/7001406102621388831#heading-7\">【Java】JVM - 各版本默认垃圾收集器 - 掘金 (juejin.cn)</a></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu41554.png\" alt=\"截屏2021-09-30下午4.15.54\"></p>\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu41831.png\" alt=\"截屏2021-09-30下午4.18.31\"></p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu42054.png\" alt=\"截屏2021-09-30下午4.20.54\" style=\"zoom:50%;\" />\n\n<h5 id=\"怎样选择垃圾回收器？\"><a href=\"#怎样选择垃圾回收器？\" class=\"headerlink\" title=\"怎样选择垃圾回收器？\"></a>怎样选择垃圾回收器？</h5><ul>\n<li>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</li>\n<li>怎样选择？<ol>\n<li>优先调整堆的大小让JVM自适应完成。</li>\n<li>如果内存小于100M，使用串行收集器</li>\n<li>如果是单核、单机程序并且没有停顿时间的要求，串行收集器</li>\n<li>如果是多CPU、高吞吐量要求、允许停顿时间超过1s，选择并行或者JVM自己选择</li>\n<li>如果是多CPU、追求低停顿时间、需快速响应，使用并发收集器；官方推荐G1，性能高。现在的互联网项目，基本都是G1</li>\n</ol>\n</li>\n</ul>\n<h5 id=\"面试题要\"><a href=\"#面试题要\" class=\"headerlink\" title=\"面试题要\"></a>面试题要</h5><ul>\n<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>\n<li>垃圾收集器工作的基本流程</li>\n</ul>\n<h4 id=\"GC-日志分析\"><a href=\"#GC-日志分析\" class=\"headerlink\" title=\"GC 日志分析\"></a>GC 日志分析</h4><h5 id=\"常用GC日志参数\"><a href=\"#常用GC日志参数\" class=\"headerlink\" title=\"常用GC日志参数\"></a>常用GC日志参数</h5><ul>\n<li><code>-XX:+PrintGC</code>：输出GC日志。类似 -verbose:gc</li>\n<li><code>-XX:+PrintGCDetails</code>：输出GC的详细日志</li>\n<li><code>-XX:+PrintGCTimeStamps</code>：输出GC的时间戳（以基准时间的形式）</li>\n<li><code>-XX:+PrintGCDateStamps</code>：输出GC的时间戳（以日期的形式，如2020-05-20T21:33:33.234+0800）</li>\n<li><code>-XX:+PrintHeapAtGC</code>：在进行GC的前后打印出堆的信息</li>\n<li><code>-Xloggc:../logs/gc.log</code>：日志文件输出路径</li>\n</ul>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu43905.png\" alt=\"截屏2021-09-30下午4.39.05\" style=\"zoom:50%;\" />\n\n<p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu45110.png\" alt=\"截屏2021-09-30下午4.51.10\"></p>\n<img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu45136.png\" alt=\"截屏2021-09-30下午4.51.36\"  />\n\n\n\n\n\n<h4 id=\"垃圾回收器的最新发展\"><a href=\"#垃圾回收器的最新发展\" class=\"headerlink\" title=\"垃圾回收器的最新发展\"></a>垃圾回收器的最新发展</h4><h5 id=\"OpenJDK12-Shenandoah-GC\"><a href=\"#OpenJDK12-Shenandoah-GC\" class=\"headerlink\" title=\"OpenJDK12 - Shenandoah GC\"></a>OpenJDK12 - Shenandoah GC</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu53406.png\" alt=\"截屏2021-09-30下午5.34.06\"></p>\n<h5 id=\"令人震惊、革命性的-GC\"><a href=\"#令人震惊、革命性的-GC\" class=\"headerlink\" title=\"令人震惊、革命性的 GC\"></a>令人震惊、革命性的 GC</h5><p><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu82546.png\" alt=\"截屏2021-09-30下午8.25.46\"></p>\n<h5 id=\"其他的垃圾回收器：AliGC\"><a href=\"#其他的垃圾回收器：AliGC\" class=\"headerlink\" title=\"其他的垃圾回收器：AliGC\"></a>其他的垃圾回收器：AliGC</h5><img src=\"https://markdown-pic-june.oss-cn-beijing.aliyuncs.com/2022/09/30/jie-ping20210930-xia-wu83227.png\" alt=\"截屏2021-09-30下午8.32.27\" style=\"zoom:50%;\" />\n\n<hr>\n","feature":true,"text":"内存与垃圾回收篇 类加载子系统 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件表示。 ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 加载的类信息存放于一块称为方法区的...","link":"","photos":[],"count_time":{"symbolsCount":"61k","symbolsTime":"56 mins."},"categories":[],"tags":[{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"},{"name":"学习笔记","slug":"学习笔记","count":8,"path":"api/tags/学习笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87\"><span class=\"toc-text\">内存与垃圾回收篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">类加载子系统</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader%E8%A7%92%E8%89%B2\"><span class=\"toc-text\">类加载器ClassLoader角色</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">类加载过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">加载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">链接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">类加载器分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">虚拟机自带的加载器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">用户自定义加载器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8EClassLoader\"><span class=\"toc-text\">关于ClassLoader</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">双亲委派机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">优势</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">沙箱安全机制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">对类加载器的引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">类的主动使用和被动使用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA\"><span class=\"toc-text\">运行时数据区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">程序计数器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">举例说明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">两个常见问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">虚拟机栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%88%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">栈的优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">面试题：开发中遇到的异常有哪些？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">栈中存储什么？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">栈运行原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">栈帧的内部结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8\"><span class=\"toc-text\">局部变量表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8ESlot%EF%BC%88%E6%A7%BD%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">关于Slot（槽）的理解</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8\"><span class=\"toc-text\">Slot的重复利用</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">举例：静态变量与局部变量的对比</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">补充说明</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88\"><span class=\"toc-text\">操作数栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">代码演示</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">栈顶缓存技术</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88%E6%8C%87%E5%90%91%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">动态链接（指向运行时常量池的方法引用）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">方法调用</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9A%E8%99%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法的调用：虚方法与非虚方法</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%9A%E5%85%B3%E4%BA%8Einvokedynamic%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">方法调用：关于invokedynamic指令</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%9A%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">方法调用：方法重写的本质</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%9A%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8\"><span class=\"toc-text\">方法调用：虚方法表</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">方法返回地址</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">一些附加信息</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">虚拟机栈的相关面试题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><span class=\"toc-text\">本地方法栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">堆的核心概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">堆是对象存储的唯一选择吗？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">逃逸分析概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">参数设置</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">逃逸分析-代码优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D\"><span class=\"toc-text\">代码优化之栈上分配</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5\"><span class=\"toc-text\">逃逸分析之同步省略</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B9%8B%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2\"><span class=\"toc-text\">逃逸分析之标量替换</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">本章小结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">方法区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0-1\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">栈、堆、方法区的交互关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HotSpot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B\"><span class=\"toc-text\">HotSpot中方法区的演进</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F%E6%B1%A0-%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">常量池-解释</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM\"><span class=\"toc-text\">设置方法区大小与OOM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9BOOM%EF%BC%9F\"><span class=\"toc-text\">如何解决这些OOM？</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">方法区的内部结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">类型信息</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9F%9F%EF%BC%88Field%EF%BC%89%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">域（Field）信息</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">方法（Method）信息</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-amp-%E5%B8%B8%E9%87%8F%E6%B1%A0\"><span class=\"toc-text\">运行时常量池 &amp; 常量池</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">方法区使用举例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">方法区的演进细节</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">方法区的垃圾回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86\"><span class=\"toc-text\">方法区的垃圾收集</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">执行引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">执行引擎概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">Java代码编译和执行过程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%BA%E5%99%A8%E7%A0%81%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">机器码、指令、汇编语言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9C%BA%E5%99%A8%E7%A0%81\"><span class=\"toc-text\">机器码</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">指令</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E9%9B%86\"><span class=\"toc-text\">指令集</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">汇编语言</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">高级语言</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E7%A0%81\"><span class=\"toc-text\">字节码</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E5%99%A8\"><span class=\"toc-text\">解释器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JIT%E7%BC%96%E8%AF%91%E5%99%A8\"><span class=\"toc-text\">JIT编译器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%9D%A5%E4%BA%86\"><span class=\"toc-text\">问题来了</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91-%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">编译 - 概念解释</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%8E%A2%E6%B5%8B%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">热点代码及探测方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">方法调用计数器</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#HotSpot-VM%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">HotSpot VM可以设置程序执行方式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#HotSpot-VM%E4%B8%ADJIT%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">HotSpot VM中JIT分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#C1%E5%92%8CC2%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">C1和C2编译器不同的优化策略</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E1%EF%BC%9A\"><span class=\"toc-text\">写在最后1：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E2%EF%BC%9A%E5%85%B3%E4%BA%8EAOT%E7%BC%96%E8%AF%91%E5%99%A8\"><span class=\"toc-text\">写在最后2：关于AOT编译器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E8%AF%95%E6%8F%90%E8%A6%81%EF%BC%9AString-%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">面试提要：String 相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#String-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">String 的基本特性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#String-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\"><span class=\"toc-text\">String 的内存分配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">字符串拼接操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#intern-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">intern( ) 使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93String%E7%9A%84intern-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">总结String的intern( ) 的使用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Intern-%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95%EF%BC%9A%E7%A9%BA%E9%97%B4%E8%A7%92%E5%BA%A6\"><span class=\"toc-text\">Intern( )效率测试：空间角度</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#StringTable-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">StringTable 的垃圾回收</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#G1%E4%B8%AD%E7%9A%84-String-%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">G1中的 String 去重操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E8%AF%95%E6%8F%90%E8%A6%81%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96\"><span class=\"toc-text\">面试提要：对象实例化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">内存布局</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E5%A4%B4\"><span class=\"toc-text\">对象头</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">实例数据</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%EF%BC%88Padding%EF%BC%89\"><span class=\"toc-text\">对齐填充（Padding）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%EF%BC%9A%E5%9B%BE%E7%A4%BA\"><span class=\"toc-text\">小结：图示</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E8%AF%95%E6%8F%90%E8%A6%81%EF%BC%9A%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">面试提要：对象访问定位</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">对象访问的两种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">句柄访问</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%EF%BC%88HostSpot%E9%87%87%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">直接访问（HostSpot采用）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\"><span class=\"toc-text\">简介：直接内存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">本地方法接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">什么是本地方法？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-Native-Method%EF%BC%9F\"><span class=\"toc-text\">为什么要使用 Native Method？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E7%8A%B6\"><span class=\"toc-text\">现状</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E7%82%B9%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8\"><span class=\"toc-text\">重点：垃圾回收器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">垃圾回收概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE\"><span class=\"toc-text\">什么是垃圾</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC\"><span class=\"toc-text\">为什么需要GC</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">早期垃圾回收</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Java垃圾回收机制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">垃圾回收相关算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记阶段：引用计数算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">引用计数算法概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">标记阶段：可达性分析算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0-2\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#GC-Roots\"><span class=\"toc-text\">GC Roots</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84-finalization-%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">对象的 finalization 机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">清除阶段：标记-清除算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">清除阶段：复制算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">清除阶段：标记-压缩算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93-1\"><span class=\"toc-text\">小结</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GC%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86\"><span class=\"toc-text\">GC分代收集</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">增量收集算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">分区收集算法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">垃圾回收相关概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#System-gc-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">System.gc( )的理解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">垃圾回收的并行与并发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%EF%BC%88Concurrent%EF%BC%89\"><span class=\"toc-text\">并发（Concurrent）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%EF%BC%88Parallel%EF%BC%89\"><span class=\"toc-text\">并行（Parallel）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">二者对比</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C\"><span class=\"toc-text\">垃圾回收的并发与并行</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F\"><span class=\"toc-text\">安全点与安全区域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E7%82%B9\"><span class=\"toc-text\">安全点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F\"><span class=\"toc-text\">安全区域</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">再谈引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89-%E2%80%93-%E4%B8%8D%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">强引用（Strong Reference） – 不回收</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89-%E2%80%93-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%8D%B3%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">软引用（Soft Reference） – 内存不足即回收</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Referenc%EF%BC%89-%E2%80%93-%E5%8F%91%E7%8E%B0%E5%8D%B3%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">弱引用（Weak Referenc） – 发现即回收</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89-%E2%80%93-%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">虚引用（Phantom Reference） – 对象回收跟踪</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8%EF%BC%88Final-Reference%EF%BC%89\"><span class=\"toc-text\">终结器引用（Final Reference）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">垃圾回收器 - 实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GC%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">GC分类与性能指标</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%88throughput%EF%BC%89\"><span class=\"toc-text\">评估GC的性能指标：吞吐量（throughput）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9A%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4%EF%BC%88pause-time%EF%BC%89\"><span class=\"toc-text\">评估GC的性能指标：暂停时间（pause time）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%90%9E%E5%90%90%E9%87%8F-vs-%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">吞吐量 vs 暂停时间</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">不同的垃圾回收器概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%91%E5%B1%95%E5%8F%B2\"><span class=\"toc-text\">垃圾收集器发展史</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">如何查看默认垃圾收集器？</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Serial-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%89\"><span class=\"toc-text\">Serial 回收器：串行回收（标记清除）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ParNew-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6%EF%BC%88%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">ParNew 回收器：并行回收（复制算法)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Parallel%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E3%80%81%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6%EF%BC%88%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95-%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%EF%BC%89\"><span class=\"toc-text\">Parallel回收器：吞吐量优先、并行回收（复制算法+标记压缩）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CMS-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F%E3%80%81%E5%B9%B6%E5%8F%91%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%89\"><span class=\"toc-text\">CMS 回收器：低延迟、并发（标记清除）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#CMS%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">CMS小结</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#G1%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F\"><span class=\"toc-text\">G1回收器：区域化分代式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#G1-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">G1 特点</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#G1-%E4%B8%8D%E8%B6%B3\"><span class=\"toc-text\">G1 不足</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">G1回收器的使用场景</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BARegion%EF%BC%9A%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6\"><span class=\"toc-text\">分区Region：化整为零</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#G1%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">G1回收垃圾过程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%9ARememberd-Set\"><span class=\"toc-text\">G1回收器垃圾回收过程：Rememberd Set</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#-1\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE\"><span class=\"toc-text\">G1回收器优化建议</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">垃圾回收器总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">怎样选择垃圾回收器？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A6%81\"><span class=\"toc-text\">面试题要</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90\"><span class=\"toc-text\">GC 日志分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8GC%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">常用GC日志参数</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%9C%80%E6%96%B0%E5%8F%91%E5%B1%95\"><span class=\"toc-text\">垃圾回收器的最新发展</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#OpenJDK12-Shenandoah-GC\"><span class=\"toc-text\">OpenJDK12 - Shenandoah GC</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BB%A4%E4%BA%BA%E9%9C%87%E6%83%8A%E3%80%81%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84-GC\"><span class=\"toc-text\">令人震惊、革命性的 GC</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9AAliGC\"><span class=\"toc-text\">其他的垃圾回收器：AliGC</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"JuneQQQ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/JuneQQQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_46925850","juejin":"https://juejin.cn/user/3927934338357197","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/432154182"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java 集合","uid":"34c2acd56bc16b503002a852a65f4137","slug":"Java集合详解","date":"2022-09-22T01:13:17.000Z","updated":"2022-09-30T10:17:47.681Z","comments":true,"path":"api/articles/Java集合详解.json","keywords":null,"cover":[],"text":"Java 集合Collection 接口 （父接口） Iterator 迭代器所有实现了Iteratable接口的类都可以通过iterator()方法获取迭代器 注意：重新获取iterator即可重置迭代器； 增强 for 循环 可以对 数组 和 集合 使用； 底层使用的仍然是 ...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"}],"author":{"name":"JuneQQQ","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/JuneQQQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_46925850","juejin":"https://juejin.cn/user/3927934338357197","customs":{"bilibili":{"icon":"/svg/bilibili-line.svg","link":"https://space.bilibili.com/432154182"}}}},"feature":true}}